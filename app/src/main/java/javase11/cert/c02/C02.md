# Capitulo 2: Fundamentos de Java

## 2.1. Crear una clase Java simple

- Un objeto es una instancia de una clase.

### 2.1.1. Constructores

- Un constructor es un método especial que se llama cuando se crea un objeto de una clase.
- Para crear una instancia de una clase, se utiliza la palabra clave `new` seguida del nombre de la clase.  Ejemplo: `new MyClass()`
- El constructor es un metodo especial que se llama cuando se crea un objeto de una clase.
- El constructor tiene el mismo nombre que la clase.
- Ejemplo:

```java
  public class MyClass {
      public MyClass() {
          // Constructor code goes here
      }
  }
  ```

- El constructor no tiene un tipo de retorno, ni siquiera void.
- El proposito de un constructor es inicializar los campos de la clase.
- El compilador Java proporciona un constructor predeterminado si no se proporciona ninguno.

### 2.1.2. Variables de instancia

- Una variable de instancia es una variable declarada dentro de una clase, pero fuera de cualquier método. Ejemplo:

```java
    public class MyClass {
        int myVar = 5;

        public static void main(String[] args) {
            MyClass obj = new MyClass();
            System.out.println(obj.myVar);
        }
    }

  ```

- Una variable de instancia se crea cuando se crea un objeto de la clase.
- Es posible inicializar una variable de instancia cuando se declara.
- Es posible inicializar una variable con el valor de otra variable inicializada anteriormente.

### 2.1.3. Bloques de inicialización

- Es posible inicializar una variable de instancia en un bloque de inicialización.
- Un bloque de inicialización es un bloque de código que se ejecuta cuando se crea un objeto de una clase.
- Un bloque de inicialización se define entre llaves `{}`.
- Ejemplo:

```java
    public class MyClass {
        int myVar;
        // bloque de inicialización 
        {
            myVar = 10;
        }

        public static void main(String[] args) {
            MyClass obj = new MyClass();
            System.out.println(obj.myVar);
        }
    }
  ```

### 2.1.4. Orden de inicializacion

- El orden de inicialización es el orden en que se inicializan las variables de instancia.
- Son ejecutados en el orden en el que aparecen en el código.
- El constructor se ejecuta después de que se hayan inicializado todas las variables de instancia.
- Ejemplo:

```java
    public class MyClass {
        int myVar = 10;

        {
            myVar = 20;
            System.out.println("Bloque de inicializacion: "+ myVar);
        }

        public MyClass() {
            myVar = 30;

            System.out.println("Constructor: "+ myVar);
        }

        public static void main(String[] args) {
            MyClass obj = new MyClass();
            System.out.println(obj.myVar);
        }
    }
  ```

- La salida del código anterior es:

```bash
  Bloque de inicializacion: 20
  Constructor: 30
  30
  ```

- El orden importa, si se cambia el orden de las variables de instancia, el orden de inicialización cambia.
- No se puede hacer referencia a una variable de instancia antes de que se inicialice.
  
### 2.1.5. Tipos de datos

- Los tipos de datos se dividen en dos categorías: primitivos y de referencia.

#### 2.1.5.1 Tipos de datos primitivos

- Los tipos de datos primitivos son los tipos de datos más básicos disponibles dentro del lenguaje Java.
- Hay 8 tipos de datos primitivos: `byte`, `short`, `int`, `long`, `float`, `double`, `boolean` y `char`.
- Los tipos de datos primitivos no almacenan objetos.

| Tipo de dato | Tamaño  | Rango                                                  | Ejemplo           |
| ------------ | ------- | ------------------------------------------------------ | ----------------- |
| byte         | 8 bits  | -128 a 127                                             | byte b = 100;     |
| short        | 16 bits | -32,768 a 32,767                                       | short s = 10000;  |
| int          | 32 bits | -2,147,483,648 a 2,147,483,647                         | int i = 100000;   |
| long         | 64 bits | -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 | long l = 100000L; |
| float        | 32 bits | 1.40129846432481707e-45 a 3.40282346638528860e+38      | float f = 234.5f; |
| double       | 64 bits | 4.94065645841246544e-324d a 1.79769313486231570e+308d  | double d = 123.4; |
| boolean      | 1 bit   | true o false                                           | boolean b = true; |
| char         | 16 bits | '\u0000' a '\uffff'                                    | char c = 'a';     |

- Los tipos float y double son usado para representar números de punto flotante.
- El tipo float tiene una precisión de 6-7 dígitos decimales y requiere de la letra `f` al final del número.
- Los tipos byte, short, int y long son usados para representar números enteros.
- Cada tipo usa el doble de bits que el tipo anterior, comenzando con byte (8 bits), short (16 bits), int (32 bits) y long (64 bits).
- Todos los tipos numericos tienen signo, lo que significa que pueden representar tanto números positivos como negativos. Byte tiene un rango de -128 a 127, por que el cero cuenta como un número positivo.
- El tipo boolean es usado para representar un valor verdadero o falso.
- short y char esta representado por 16 bits, pero el rango de valores de char es diferente al de short. El tipo char es usado para representar caracteres Unicode y no tiene signo, por lo que puede representar valores de 0 a 65535.
- El compilador permite usarlos de forma intercambiable, pero no es recomendable. Ejemplo: `char c = 65;` es lo mismo que `char c = 'A';`
- Los tipos como double y float se almacenan en notacion cientifica. Ejemplo: `double d = 1.234e2;` es lo mismo que `double d = 123.4;`
- El numero de bits sirve para determinar cuanta memoria se usa para almacenar un valor. Ejemplo: `int i = 100;` usa 32 bits de memoria.

#### Literales

- Un literal es un valor que se escribe directamente en el código.
- Una literal numerica entera se asume como un int, pero se puede especificar que sea un long agregando la letra `L` al final del numero.
- Si el rango de un literal numerico entero excede el rango de un int, se debe agregar la letra `L` al final del numero.
- Una literal numerica con punto decimal se asume como un double, pero se puede especificar que sea un float agregando la letra `f` al final del numero.
- Se pueden especificar numeros cambiando la base. Ejemplo: `int i = 0b101;` es lo mismo que `int i = 5;`
  - Octal: digitos del 0 al 7 con un 0 como prefijo. Ejemplo: `int i = 010;` es lo mismo que `int i = 8;`
  - Hexadecimal: digitos del 1 al 9 y letras A a F con prefijo 0X. Ejemplo `int i = 0x10;` es lo mismo que `int i = 16;`
  - Binario: digitos 0 y 1 con una `B` como prefijo `int i = 0b10;` es lo mismo que `int i = 2;`
  - Decimal: `int i = 10;`

#### Caracteres de Guion Bajo

- Los caracteres de guion bajo se pueden usar en literales numericos para mejorar la legibilidad. Ejemplo: `int i = 1_000_000;` es lo mismo que `int i = 1000000;`
- Se pueden usar en cualquier parte del literal, excepto al principio o al final o inmediatamente antes o despues del punto decimal. Ejemplos:

```java
  int i = _1000; // No compila
  int i = 1000_; // No compila
  double i = 10_.00; // No compila
  double i = 10._00; // No compila
  double i = 10.00_; // No compila
  double i = 10_00.00; // Compila
  double i = 10_00.0_0; // Compila

  ```

#### Usando tipos de referencia

- Los tipos de referencia son usados para referirse a objetos.
- Los tipos de referencia no almacenan objetos, solo almacenan referencias a objetos en la memoria.
- Solo se pueden usar referencias para acceder a los objetos.
- Una referencia puede ser asignada a otro objeto del mismo tipo o de un tipo compatible.
- Una referencia puede ser asignada a un objeto usando new.

#### Diferencias entre primitive y referencia

- Los tipos de referencia pueden ser asignados null, los tipos primitivos no.
- Los tipos de referencia tienen un valor por defecto de null, los tipos primitivos tienen un valor por defecto.
- Las referencias pueden ser usadas para llamar metodos, los tipos primitivos no.
- Los tipos primitivos comienzan con minuscula, los tipos de referencia comienzan con mayuscula.

### Declarando variables

- Una variable es una region en la memoria que almacena un valor.
- Para declarar una variable se debe especificar el tipo de dato y el nombre de la variable.
- Para inicializar una variable se debe asignar un valor.
- Ejemplo: `int i = 10;`
- Existen reglas para los identificadores
- Los identificadores se refieren a los nombres de las variables, metodos, clases, paquetes y interfaces.
- Existen 4 reglas para los identificadores:
  - Los identificadores deben comenzar con una letra, un signo de dolar `$` o un guion bajo `_`.
  - A partir de Java 9, el guion bajo `_` solo no se puede usar como un identificador.
  - Despues del primer caracter, los identificadores pueden contener numeros, pero no pueden comenzar con numero.
  - Los identificadores no pueden ser palabras reservadas.
  - Los identificadores son sensibles a mayusculas y minusculas.

#### Palabras reservadas

- Las palabras reservadas son palabras que tienen un significado especial en el lenguaje Java.
- No se pueden usar como identificadores.
  
| abstract | continue | for        | new       | switch       |
| -------- | -------- | ---------- | --------- | ------------ |
| assert   | default  | goto       | package   | synchronized |
| boolean  | do       | if         | private   | this         |
| break    | double   | implements | protected | throw        |
| byte     | else     | import     | public    | throws       |
| case     | enum     | instanceof | return    | transient    |
| catch    | extends  | int        | short     | try          |
| char     | final    | interface  | static    | void         |
| class    | finally  | long       | strictfp  | volatile     |
| const    | float    | native     | super     | while        |

Ejemplo de nombre de identificadores validos

- float $rate;
- boolean _new;
- char __$1;

Ejemplo de nombre de identificadores invalidos

- int 1stName; // comienza con un numero
- int my@street; // contiene un caracter especial
- int my-street; // contiene un caracter especial
- int my street; // contiene un espacio
- int my*street; // contiene un caracter especial
- int my#street; // contiene un caracter especial
- int my%street; // contiene un caracter especial
- double public; // palabra reservada
- short _; // guion bajo solo no es valido a partir de Java 9

#### Estilo: Camel Case

- El estilo Camel Case es un estilo de escritura en el que las palabras se escriben sin espacios y la primera letra de cada palabra se escribe en mayuscula.
- Los nombres de las clases comienzan con mayuscula.
- Los nombres de los metodos comienzan con minuscula.
- Los nombres de las variables comienzan con minuscula.
- Los nombres de las constantes se escriben en mayuscula.

#### Declarando variables multiples

- Es posible declarar multiples variables del mismo tipo en una sola linea.
- Ejemplo: `int i, j, k;`
- Se puede inicializar multiples variables en una sola linea asignando un valor a cada variable.
- Ejemplo: `int i = 10, j = 20, k = 30;`

### Inicializando variables

- Antes de usar una variable, esta debe ser declarada e inicializada.
- Algunos tipos se inicializan automaticamente con un valor por defecto.
- Otros tipos deben ser inicializados manualmente.

#### Variables locales

- Las variables locales son variables declaradas dentro de un metodo, constructor o bloque de inicializacion.
- Las variables locales no tienen valores por defecto, por lo que deben ser inicializadas antes de usarlas.
- El compilador no permite usar una variable local sin inicializar.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          int myVar;
          if (args.length > 0)
              myVar = 10;
          System.out.println(myVar); // No compila
      }
  }
  ```

- La variable debe de ser inicializada en todos los caminos posibles.

#### Pasando variables a constructores y metodos

- Es posible pasar variables a constructores y metodos.
- Estas son llamadas variables locales que han sido inicializadas.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          int myVar = 10; // debe de ser inicializada
          printVar(myVar);

          int myVar2; // no inicia
         printVar(myVar2); // No compila
      }

      public static void printVar(int myVar) {
          System.out.println(myVar);
      }
  }
  ```

#### Definiendo vaiables de instancia y de clase

- Las variables de instancia son variables declaradas dentro de una clase, pero fuera de cualquier metodo.
- Las variables de instancia se inicializan cuando se crea un objeto de la clase.
- Son usualmente llamadas campos o atributos.
- Una variable de clase es una variable declarada dentro de una clase, pero fuera de cualquier metodo, con la palabra clave `static`.
- Una variable de clase se inicializa cuando se carga la clase.
- Una variable de clase es compartida por todos los objetos de la clase.
- Una variable de clase es usualmente llamada variable estatica.
- Ejemplo:

```java
  public class MyClass {
      int myVar; // variable de instancia
      static int myVar2; // variable de clase
  }
  ```

- Las variables de instancia y de clase se inicializan automaticamente con un valor por defecto.
- Las variables de instancia y de clase pueden ser inicializadas manualmente.
- Las variables de instancia y de clase pueden ser inicializadas en un bloque de inicializacion.

#### Valores por defecto por tipo de dato

| Tipo de dato           | Valor por defecto |
| ---------------------- | ----------------- |
| byte, short, int, long | 0                 |
| float, double          | 0.0               |
| boolean                | false             |
| char                   | '\u0000'    (NUL) |
| Todas las referencias  | null              |

#### Inferencia de tipos de datos con var

- A partir de Java 10, es posible declarar variables locales sin especificar el tipo de dato.
- El tipo de dato es inferido por el compilador.
- La palabra clave `var` se usa para declarar variables locales.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          var myVar = 10;
          System.out.println(myVar);
      }
  }
  ```

- La inferencia de tipos de datos no se puede usar para declarar variables de instancia o de clase.
- La inferencia de tipos de datos no se puede usar para declarar variables sin inicializar.
- El tipo de variable no puede cambiar despues de ser inferido.
- Para inferir una variable, el compilador usa el tipo de dato de la expresion a la derecha del signo `=`.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          var myVar = 10;
          myVar = "Hello"; // No compila

          var myVar2;
          if (args.length > 0)
              myVar2 = 10;
              else  
                myVar2 = "Hello"; // No compila
            System.out.println(myVar2); // No compila
      
      }
  }
  ```

- La inferencia de tipos de datos no se puede usar para declarar variables sin inicializar.
- No se pueden asignar null a una variable inferida, solamente despues de que se le ha asignado un valor.
- No se puede asignar multiples variables en una sola linea.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          var myVar = null; // No compila
          var myVar2 = 10, myVar3 = 20; // No compila
      }
  }
  ```

- Una variable local puede ser nombrada var, pero no es recomendable.
- La palabra var no puede ser usada para nombrar una clase, interfaz o enum
- No es recomendado usar var para todas las variables locales, solo para variables locales con un tipo de dato largo.

#### Reglas de var

- Una var es usada para declarar variables locales en un metodo, constructor o bloque de inicializacion.
- Una var no puede ser usada en parametros de metodos, constructores, variables de instancia o variables de clase.
- Una var siempre se inicializa con un valor en la misma linea en la que es declarada.
- El valor de una var puede ser cambiado, pero no su tipo.
- Una var no puede ser inicializada con null.
- Una var no es permitida en declaraciones multiples.
- Una var es un tipo de dato, no una palabra reservada. Es posible usarla como identificador excepto en clases, interfaces y enums.

### Alcance de las variables

- El alcance de una variable es la parte del programa donde la variable es accesible.
- Las variables locales solo son accesibles dentro del metodo, constructor o bloque de inicializacion en el que son declaradas.
- Las variables de instancia son accesibles dentro de la clase, pero fuera de cualquier metodo, constructor o bloque de inicializacion.
- Las variables de clase son accesibles dentro de la clase, pero fuera de cualquier metodo, constructor o bloque de inicializacion.
- Las variables de clase son compartidas por todos los objetos de la clase.

#### Limitando el alcance

- Es posible limitar el alcance de una variable declarandola dentro de un bloque.
- Un bloque es un grupo de sentencias encerradas entre llaves `{}`.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          int myVar = 10;
          {
              int myVar2 = 20;
              System.out.println(myVar);
              System.out.println(myVar2);
          }
          System.out.println(myVar);
          System.out.println(myVar2); // No compila

          if (args.length > 0) {
              int myVar3 = 30;
              System.out.println(myVar3);
          }
            System.out.println(myVar3); // No compila
      }
  }
  ```

- La variable myVar es accesible dentro del bloque en el que fue declarada y en cualquier bloque dentro de ese bloque.
- La variable myVar2 solo es accesible dentro del bloque en el que fue declarada.
- La variable myVar3 solo es accesible dentro del bloque en el que fue declarada.

#### Anidando alcance

- Es posible anidar bloques dentro de otros bloques.
- Las variables declaradas en un bloque son accesibles en bloques anidados.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          int myVar = 10;
          {
              int myVar2 = 20;
              {
                  int myVar3 = 30;
                  System.out.println(myVar);
                  System.out.println(myVar2);
                  System.out.println(myVar3);
              }
          }
      }
  }
  ```

#### Rastreando el alcance

- Es posible rastrear el alcance de una variable usando el principio de la sombra.
- El principio de la sombra es un principio de programacion que permite que una variable local tenga el mismo nombre que una variable de instancia o de clase.
- Ejemplo:

```java
  public class MyClass {
      int myVar = 10;

      public static void main(String[] args) {
          int myVar = 20;
          System.out.println(myVar);
      }
  }
  ```

#### Aplicando Alcance a las clases

- El alcance de una clase es la parte del programa donde la clase es accesible.
- Las variables de instancia estan disponible en cualquier parte de la clase y duran lo que dure el objeto.
- Las variables de clase estan disponibles en cualquier parte de la clase. Son compartidas por todos los objetos de la clase y duran lo que dure la clase.
- Ejemplo:

```java
  public class MyClass {
      int myVar = 10;
      static int MY_VAR = 20;

      public static void main(String[] args) {
          MyClass obj = new MyClass();
          System.out.println(obj.myVar);
          System.out.println(MY_VAR);
      }
  }
  ```

#### Reglas del alcance

- Variables locales: solo son accesibles dentro del metodo, constructor o bloque de inicializacion en el que son declaradas.
- Variables de instancia: son accesibles dentro de la clase, en cualquier metodo, constructor o bloque de inicializacion. Son accesibles a traves de los objetos de la clase hasta que el objeto es destruido.
- Variables de clase: son accesibles dentro de la clase, en cualquier metodo, constructor o bloque de inicializacion. Son accesibles a traves de los objetos de la clase y son compartidas por todos los objetos de la clase hasta que el programa termine

### Destruyendo objetos

- Los objetos son destruidos por el recolector de basura.
- El recolector de basura es un programa que se ejecuta en segundo plano y se encarga de destruir los objetos que ya no son usados.
- El recolector de basura es parte del entorno de ejecucion de Java.
- Todos los objetos son almacenados en la memoria heap.
- El heap es una region de la memoria que almacena objetos del programa
- El heap es compartido por todos los hilos del programa.
- El heap es limpiado por el recolector de basura.
- El heap puede ser grande, pero no es infinito.
- El recolector de basura es un proceso automatico, pero es posible llamarlo manualmente.

#### Recolectando basura

- El recolector de basura es un proceso automatico, libera memoria eliminando objetos que ya no son usados.
- Hay varios algoritmos de recoleccion de basura, pero el mas comun es el algoritmo de marcado y barrido.
- El algoritmo de marcado y barrido es un algoritmo de recoleccion de basura que marca los objetos que son usados y elimina los que no son usados.

#### Elegible para recolector de basura

- Un objeto es elegible para el recolector de basura si no hay referencias a el.
- El recolector  de basura no es inmediato, garantizado, obligatorio, predecible o deterministico, no se sabe cuando se ejecutara.
- Para evitar problemas con la memoria es necesario asegurarse que los objetos sean elegibles para el recolector de basura cuando ya no sean usados. La JVM tiene la responsabilidad de recolectar la basura.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          MyClass obj = new MyClass();
          obj = null; // obj es elegible para el recolector de basura
      }
  }
  ```

#### Llamando al recolector de basura

- Es posible llamar al recolector de basura manualmente usando el metodo `System.gc()`.
- El metodo `System.gc()` es un metodo estatico de la clase `System` que se usa para llamar al recolector de basura.
- El metodo `System.gc()` no garantiza que el recolector de basura se ejecute.

#### Trazando eligibilidad

- La JVM monitorea cada objeto hasta que determina que es elegible para el recolector de basura.
- Un objeto ya no es alcanzable si
  - La variable que lo referencia es reasignada.
  - La variable que lo referencia es establecida en null.
  - La variable que lo referencia es declarada dentro de un bloque y el bloque termina.
  - La variable que lo referencia es declarada como un parametro de un metodo y el metodo termina.
  - La variable que lo referencia es declarada como un parametro de un constructor y el constructor termina.
  - La variable que lo referencia es declarada como una variable de instancia y el objeto que la contiene es destruido.
  -
- Una referencia es una variable que apunta a un objeto.
- Una referencia puede ser reasignada.
- Si el objeto al que apunta una referencia ya no es alcanzable, el objeto es elegible para el recolector de basura.
- Un objeto no es alcanzaable si no hay referencias a el.
- Ejemplo:

```java
  public class MyClass {
      public static void main(String[] args) {
          MyClass obj = new MyClass();
          obj = null; // obj es elegible para el recolector de basura
          String uno, dos;
            uno = new String("Uno");
            dos = new String("Dos");
            uno = dos; // "Uno" es elegible para el recolector de basura
            uno = null; // "Uno" es elegible para el recolector de basura
            dos = null; // "Dos" es elegible para el recolector de basura
      }
  }
  ```

- finalize es un metodo que se ejecuta antes de que un objeto sea destruido por el recolector de basura.
  - El metodo finalize es un metodo de la clase Object.
  - El metodo finalize es invocado por el recolector de basura.
  - El metodo finalize es obsoleto, no se recomienda usarlo.

### Resumen

- Un objeto es una instancia de una clase.
- Los constructores son metodos especiales que se llaman cuando se crea un objeto de una clase.
- Los primitivos son tipos de datos basicos disponibles en el lenguaje Java.
- Declarar una variable significa especificar el tipo de dato y el nombre de la variable.
  - Las variables locales solo son accesibles dentro del metodo, constructor o bloque de inicializacion en el que son declaradas y deben de ser inicializadas antes de usarlas.
  - Las variables de instancia son variables declaradas dentro de una clase, pero fuera de cualquier metodo. Se inicializan cuando se crea un objeto de la clase.
  - Las variables de clase son variables declaradas dentro de una clase, pero fuera de cualquier metodo, con la palabra clave `static`. Se inicializan cuando se carga la clase.
- El recolector de basura es un proceso automatico que se encarga de destruir los objetos que ya no son usados.

#### Escencial

- Reconocer constructor: tiene el mismo nombre que la clase y no tiene tipo de retorno.
- Reconocer nombres de variables validos: comienzan con una letra, un signo de dolar `$` o un guion bajo `_`. Despues del primer caracter, los identificadores pueden contener numeros, pero no pueden comenzar con numero. Los identificadores no pueden ser palabras reservadas. Los identificadores son sensibles a mayusculas y minusculas.
- Usar var correctamente: solo se puede usar para declarar variables locales. Siempre se inicializa con un valor en la misma linea en la que es declarada. El valor de una var puede ser cambiado, pero no su tipo. No se puede asignar null a una variable inferida, solamente despues de que se le ha asignado un valor. No se puede asignar multiples variables en una sola linea. No se puede usar para nombrar una clase, interfaz o enum. No es recomendado usar var para todas las variables locales, solo para variables locales con un tipo de dato largo.
- Reconocer alcance de variables: las variables locales solo son accesibles dentro del metodo, constructor o bloque de inicializacion en el que son declaradas. Las variables de instancia son accesibles dentro de la clase, pero fuera de cualquier metodo, constructor o bloque de inicializacion. Las variables de clase son accesibles dentro de la clase, pero fuera de cualquier metodo, constructor o bloque de inicializacion.
- Identificar cuando un objeto es elegible para el recolector de basura: un objeto es elegible para el recolector de basura si no hay referencias a el.

---

### Preguntas

#### 1. ¿Cuáles de los siguientes son identificadores Java válidos? (Elija todas las que correspondan)

1. [ ] A. _
1. [X] B. _holaMundo$
1. [ ] C. true
1. [ ] D. java.lang
1. [X] E. Public
1. [ ] F. 1980_s
1. [X] G. _Q2_

Respuesta: B, E, G

Explication: Los identificadores pueden comenzar con una letra, un signo de dolar `$` o un guion bajo `_`. Despues del primer caracter, los identificadores pueden contener numeros, pero no pueden comenzar con numero. Los identificadores no pueden ser palabras reservadas. Los identificadores son sensibles a mayusculas y minusculas.

- A. No es valido porque solo contiene un guion bajo.
- B. Es valido porque comienza con un guion bajo y contiene un signo de dolar.
- C. No es valido porque es una palabra reservada.
- D. No es valido porque contiene un punto.
- E. Es valido porque comienza con una letra mayuscula.
- F. No es valido porque comienza con un numero.
- G. Es valido porque comienza con un guion bajo y contiene caracteres

#### 2. ¿Qué líneas imprime el siguiente programa? (Elija todas las que correspondan)

```java

public  class Botella { // Linea 1
 private String  marca ; // Linea 2
 private boolean vacio; // Linea 3
 public static float codigo; // Linea 4
 
 public static void main (String [] argumentos) { // Linea 5
    Botella wb = new Botella(); // Linea 6
    System.out.println("Vacío = " + wb.vacio); // Linea 7
    System.out.println("Marca = " + wb.marca); // Linea 8
    System.out.println("Código = " + codigo); // Linea 9
    } 
}    

```

1. [ ] A. La línea 8 genera un error del compilador.
1. [ ] B. La línea 9 genera un error del compilador.
1. [ ] C. Vacío =
1. [X] D. Vacío = falso
1. [ ] E. Marca =
1. [X] F. Marca = null
1. [X] G. Código = 0.0
1. [ ] H. Código = 0f

Respuesta: D, F, G

Explicacion:

- La linea 8 no genera un error del compilador porque la variable marca es inicializada con null.
- La linea 9 no genera un error del compilador porque la variable codigo es inicializada con 0.0.
- La linea 7 imprime Vacío = falso porque la variable vacio es inicializada con false.
- La linea 8 imprime Marca = null porque la variable marca es inicializada con null.
- La linea 9 imprime Código = 0.0 porque la variable codigo es inicializada con 0.0.
  
#### 3. ¿Cuál de los siguientes fragmentos de código sobre var se compila sin problemas cuando se usa en un ¿método? (Elija todas las que correspondan)

1. [ ] A. var primavera = null;
2. [X] B. var temporada = "hojas";
3. [ ] C. var tarde = 2; tarde = null;
4. [X] D. var noche = new Object();
5. [X] E. var dia = 1/0;
6. [ ] F. var invierno = 12, frío;
7. [ ] G. var otoño = 2, verano = 2;
8. [X] H. var mañana = ""; mañana = null;

Respuesta B, D, E, H

Explicacion:

- La linea A no compila porque la variable primavera es inicializada con null.
- La linea B compila porque la variable temporada es inicializada con un String.
- La linea C no compila porque la variable tarde es inicializada con un int y luego con null.
- La linea D compila porque la variable noche es inicializada con un objeto.
- La linea E compila porque la variable dia es inicializada con una division por cero.
- La linea F no compila porque la variable invierno es inicializada con un int y la variable frio no es inicializada.
- La linea G no compila porque var no puede ser usada para declarar multiples variables.
- La linea H compila porque la variable mañana es inicializada con un String y luego con null.

#### 4. ¿Cuáles de las siguientes afirmaciones sobre el fragmento de código son verdaderas? (Elija todas las que correspondan)

```java

short mascotas = 5L; /// Linea 4
int numGranos = 2.0; // Linea 5
String nombre = "Desaliñado"; // Linea 6
int d = mascotas.length(); // Linea 7
int e = numGranos.length;  // Linea 8
int f = nombre.length(); // Linea 9

```

1. [X] A. La línea 4 genera un error del compilador.
1. [X] B. La línea 5 genera un error del compilador.
1. [ ] C. La línea 6 genera un error del compilador.
1. [X] D. La línea 7 genera un error del compilador.
1. [X] E. La línea 8 genera un error del compilador.
1. [ ] F. La línea 9 genera un error del compilador.

Respuesta: A, B, D, E

Explicacion:

- La linea 4 genera un error del compilador porque la variable mascotas es de tipo short y se le esta asignando un long.
- La linea 5 genera un error del compilador porque la variable numGranos es de tipo int y se le esta asignando un double.
- La linea 6 no genera un error del compilador porque la variable nombre es de tipo String.
- La linea 7 genera un error del compilador porque la variable mascotas es de tipo short y no tiene el metodo length().
- La linea 8 genera un error del compilador porque la variable numGranos es de tipo int y no tiene el atributo length.
- La linea 9 no genera un error del compilador porque la variable nombre es de tipo String y tiene el metodo length().

#### 5. ¿Qué afirmaciones sobre la siguiente clase son verdaderas? (Elija todas las que correspondan)

```java
    public class Rio { // Linea 1
        int Profundidad = 1; // Linea 2
        float temperatura = 50.0; // Linea 3
        public void flujo() { // Linea 4
            for (int i = 0; i < 1; i++) { // Linea 5
                int profundidad  = 2; // Linea 6
                profundidad++;  // Linea 7
                temperatura--; //  Linea 8
            } // Linea 9
            System.out.println(profundidad); // Linea 10
            System.out.println(temperatura); } // Linea 11
        public static void main (String... s) { // Linea 12
                new Rio().flujo(); // Linea 13
        } } // Linea 14
```

1. [X] A. La línea 3 genera un error del compilador.
1. [ ] B. La línea 6 genera un error del compilador.
1. [ ] C. La línea 7 genera un error del compilador.
1. [X] D. La línea 10 genera un error del compilador.
1. [ ] E. El programa imprime 3 en la línea 10.
1. [ ] F. El programa imprime 4 en la línea 10.
1. [ ] G. El programa imprime 50.0 en la línea 11.
1. [ ] H. El programa imprime 49.0 en la línea 11.

Respuesta: A, D

Explicacion:

- La linea 3 genera un error del compilador porque la variable temperatura es de tipo float y se le esta asignando un double.
- La linea 6 no genera un error de compilador por que la variable profundidad es declarada con mayuscula en la clase
- La linea 7 no genera un error del compilador porque la variable profundidad es declarada dentro del bloque
- La linea 10 genera un error del compilador porque la variable profundidad es declarada dentro del bloque y no es accesible fuera de el.
- La linea 11 no genera un error del compilador porque la variable temperatura es declarada dentro de la clase y es accesible dentro del metodo flujo.

#### 6. ¿Cuáles de las siguientes son correctas? (Elija todas las que correspondan)

1. [ ] A. Una variable de instancia de tipo float tiene por defecto 0.
1. [ ] B. Una variable de instancia de tipo char tiene como valor predeterminado null.
1. [X] C. Una variable de instancia de tipo double tiene por defecto 0.0.
1. [ ] D. Una variable de instancia de tipo int por defecto es nula.
1. [X] E. Una variable de instancia de tipo String tiene como valor predeterminado nulo.
1. [ ] F. Una variable de instancia de tipo String por defecto es la cadena vacía "".
1. [ ] G. Ninguna de las anteriores

- Respuesta: C, E

Explicacion:

- Una variable de instancia de tipo float tiene por defecto 0.0f.
- Una variable de instancia de tipo char tiene como valor predeterminado '\u0000'.
- Una variable de instancia de tipo double tiene por defecto 0.0.
- Una variable de instancia de tipo int por defecto es 0.
- Una variable de instancia de tipo String tiene como valor predeterminado null.

#### 7. ¿Cuáles de las siguientes son correctas? (Elija todas las que correspondan)

1. [ ] A. Una variable local de tipo booleano tiene por defecto nulo.
1. [ ] B. Una variable local de tipo float tiene por defecto 0.0f.
1. [ ] C. Una variable local de tipo doble tiene por defecto 0.
1. [ ] D. Una variable local de tipo Objeto tiene el valor predeterminado nulo.
1. [ ] E. Una variable local de tipo booleano tiene el valor predeterminado falso.
1. [ ] F. Una variable local de tipo float tiene por defecto 0.0.
1. [X] G. Ninguna de las anteriores

Respuesta: G

Explicacion:

- Una variable local no tiene valor por defecto, debe ser inicializada antes de usarse.

#### 8. ¿Cuáles de las siguientes afirmaciones son verdaderas? (Elija todas las que correspondan)

1. [ ] A. Una variable de clase de tipo booleano tiene por defecto 0.
1. [X] B. Una variable de clase de tipo booleano por defecto es falso.
1. [ ] C. Una variable de clase de tipo booleano tiene por defecto nulo.
1. [ ] D. Una variable de clase de tipo long tiene por defecto nulo.
1. [X] E. Una variable de clase de tipo long tiene por defecto 0L.
1. [ ] F. Una variable de clase de tipo long tiene por defecto 0.
1. [ ] G. Ninguna de las anteriores

Respuesta:  B, E

Explicacion:

- Una variable de clase de tipo booleano por defecto es falso.
- Una variable de clase de tipo long tiene por defecto 0L.

#### 9 . ¿Cuáles de las siguientes afirmaciones sobre la recolección de basura son correctas? (Elija todas las que correspondan)

1. [ ] A. Se garantiza que llamar a System.gc() liberará memoria al destruir objetos elegibles.
para la recolección de basura.
1. [ ] B. La recolección de basura se realiza según un horario establecido.
1. [X] C. La recolección de basura permite a la JVM recuperar memoria para otros objetos.
1. [ ] D. La recolección de basura se ejecuta cuando su programa ha consumido la mitad de la memoria disponible.
1. [X] E. Un objeto puede ser elegible para la recolección de basura pero nunca eliminarse del heap.
1. [X] F. Un objeto es elegible para la recolección de basura una vez que no se puede acceder a ninguna referencia a él en el programa.
1. [ ] G. Marcar una variable como final significa que su objeto asociado nunca será basura.

Respuesta: C, E, F

Expliacion:

- No se garantiza que llamar a System.gc() liberará memoria al destruir objetos elegibles para la recolección de basura.
- La recoleccion de basura no se realiza segun un horario establecido.
- La recoleccion de basura permite a la JVM recuperar memoria para otros objetos.
- La recoleccion de basura no se ejecuta cuando su programa ha consumido la mitad de la memoria disponible.
- Un objeto puede ser elegible para la recoleccion de basura pero nunca eliminarse del heap.
- Un objeto es elegible para la recoleccion de basura una vez que no se puede acceder a ninguna referencia a el en el programa.
- Marcar una variable como final no significa que su objeto asociado nunca será basura.

#### 10. ¿Qué afirmaciones sobre la siguiente clase son correctas? (Elija todas las que correspondan)

```java
public class Caja { 
  String color; 
  long edad; 
    public void Caja() { // Linea 4
        color = "azul"; 
        edad = 1200; 
    } 
    public static void main (String [] tiempo) {
        var p = nueva Caja();
        var q = nueva Caja();
        p.color = "verde";
        p.edad = 1400; // Linea 12
        p = q; // Linea 13
        System.out.println("Q1="+q.color); 
        System.out.println("Q2="+q.edad);
        System.out.println("P1="+p.color);
        System.out.println("P2="+p.edad); 
     } 
 }
```

1. [ ] A. Imprime Q1=azul.
1. [ ] B. Imprime Q2=1200.
1. [x] C. Imprime P1=null.
1. [ ] D. Imprime P2=1400.
1. [ ] E. La línea 4 no se compila.
1. [ ] F. La línea 12 no se compila.
1. [ ] G. La línea 13 no se compila.
1. [ ] H. Ninguna de las anteriores

Respuesta: A, B

Explicacion:

- El programa compila por lo que E, F y G son incorrectas.
- La linea 4 no es un constructor porque tiene un tipo de retorno por lo que A y B es incorrecta.

#### 11. ¿Cuál de los siguientes completa legalmente el espacio en blanco para que pueda ejecutar el método main() desde el ¿línea de comando? (Elija todas las que correspondan)

public static void main(_______) {}

1. [X] A. String... var
1. [ ] B. String Mis.Nombres[]
1. [ ] C. String[] 123
1. [X] D. String[] _nombres
1. [X] E. String... $n
1. [ ] F. var nombres
1. [ ] G. String myArgs

Respuesta A, D, E

Explicacion:

1. El nombre var puede ser usado como nombre de variable
2. El nombre _nombres puede ser usado como nombre de variable
3. El nombre $n puede ser usado como nombre de variable
4. El nombre myArgs puede ser usado como nombre de variable pero no es un parametro valido para el metodo main
5. El nombre Mis.Nombres[] no puede ser usado como nombre de variable
6. El nombre 123 no puede ser usado como nombre de variable
7. var no puede ser usado como tipo de dato de variable

#### 12.  ¿Cuál de las siguientes expresiones, cuando se insertan de forma independiente en la línea en blanco, permiten el código a compilar? (Elija todas las que correspondan)

```java
public void imprimeMagia() { 
    double magia = ______; 
    System.out.println(magia);
}
```

1. [X] A. 3_1
1. [ ] B. 1_329_.0
1. [ ] C. 3_13.0_
1. [ ] D. 5_291._2
1. [X] E. 2_234.0_0
1. [x] F. 9___6
1. [ ] G. _1_3_5_0
1. [ ] H. Ninguna de las anteriores

Respuesta: A, E, F

Explicacion:

- La expresion 3_1 es valida porque es un double
- La expresion 1_329_.0 no es valida porque contiene un punto despues del guion bajo
- La expresion 3_13.0_ no es valida porque termina con guion bajo
- La expresion 5_291._2 no es valida porque contiene un punto antes del guion bajo
- La expresion 2_234.0_0 es valida
- La expresion _1_3_5_0 no es valida porque inicia con un guion bajo

#### 13. Supongamos que tenemos una clase llamada Conejo. ¿Cuáles de las siguientes afirmaciones son verdaderas?

(Elija todas las que correspondan).

```java
 public class Conejo {
 public static void main (String [] argumentos) {
    Conejo uno = new Conejo(); // Linea 3
    Conejo dos = new Conejo(); // Linea 4
    Conejo tres = uno;
    uno = null; // Linea 6
    Conejo cuatro = uno;
    tres = null; // Linea 8
    dos = null; // Linea 9
    dos = new Conejo(); // Linea 10
    System.gc();   // Linea 11
    } } // Linea 12

```

1. [ ] A. El objeto Conejo creado en la línea 3 es primero elegible para la recolección de basura inmediatamente.
siguiente línea 6.
1. [x] B. El objeto Conejo creado en la línea 3 es primero elegible para la recolección de basura inmediatamente
siguiente línea 8.
1. [ ] C. El objeto Conejo creado en la línea 3 es primero elegible para la recolección de basura inmediatamente
siguiente línea 12.
1. [X] D. El objeto Conejo creado en la línea 4 es primero elegible para la recolección de basura inmediatamente
siguiente línea 9.
1. [ ] E. El objeto Conejo creado en la línea 4 es primero elegible para la recolección de basura inmediatamente
siguiente línea 11.
1. [ ] F. El objeto Conejo creado en la línea 4 es primero elegible para la recolección de basura inmediatamente
siguiente línea 12.
1. [ ] G. El objeto Conejo creado en la línea 10 es primero elegible para la recolección de basura inmediatamente
siguiente línea 11.
1. [X] H. El objeto Conejo creado en la línea 10 es primero elegible para la recolección de basura inmediatamente
siguiente línea 12.

Respuesta: B, D, H

Explicacion:

- El objeto Conejo creado en la línea 3 es primero elegible para la recolección de basura inmediatamente siguiente línea 8.
- El objeto Conejo creado en la línea 4 es primero elegible para la recolección de basura inmediatamente siguiente línea 9.
- El objeto Conejo creado en la linea 10 es primero elegible para la recoleccion de basura inmediatamente siguiente linea 12.

#### 14. ¿Cuáles de las siguientes afirmaciones sobre var son verdaderas? (Elija todas las que correspondan)

1. [ ] A. Una var se puede utilizar como parámetro del constructor.
1. [x] B. El tipo de var se conoce en el momento de la compilación.
1. [x] C. Una var no se puede utilizar como variable de instancia.
1. [ ] D. Una var se puede utilizar en una declaración de asignación de múltiples variables.
1. [ ] E. El valor de var no puede cambiar en tiempo de ejecución.
1. [x] F. El tipo de var no puede cambiar en tiempo de ejecución.
1. [ ] G. La palabra var es una palabra reservada en Java.

Respuesta: B, C, F

Explicacion:

- El tipo de var se conoce en el momento de la compilación.
- Una var no se puede utilizar como variable de instancia.
- El tipo de var no puede cambiar en tiempo de ejecución.

#### 15. Dada la siguiente clase, ¿cuál de las siguientes líneas de código puede reemplazar de forma independiente? ¿INSERTAR EL CÓDIGO AQUÍ para compilar el código? (Elija todas las que correspondan)

```java
public class Precio {
 public void admision() { 
    INSERTAR EL CÓDIGO AQUÍ 
    System.out.print(cantidad); 
    }
}
```

1. [ ] A. int Cantidad = 0b11;
1. [ ] B. int cantidad = 9L;
1. [X] C. int cantidad = 0xE;
1. [ ] D. int cantidad = 1_2.0;
1. [ ] E. double cantidad = 1_0_.0;
1. [X] F. int cantidad = 0b101;
1. [X] G. double cantidad = 9_2.1_2;
1. [ ] H. double cantidad = 1_2_.0_0;

Respuesta: C, F, G

Explicacion:

- La linea A no compila por uqe la variable cantidad esta en mayuscula
- La linea B no compila por que la variable cantidad es de tipo int y se le esta asignando un long
- La linea C compila por que la variable cantidad es de tipo int y se le esta asignando un hexadecimal
- La linea D no compila por que la variable cantidad es de tipo int y se le esta asignando un double
- La linea E no compila por que la variable es inicializada con un valor invalido para un double por que tiene un guion bajo antes del punto
- La linea F compila por que la variable cantidad es de tipo int y se le esta asignando un binario
- La linea G compila por que la variable cantidad es de tipo double y se le esta asignando un double
- La linea H no compila por que la variable es inicializada con un valor invalido para un double por que tiene un guion bajo antes del punto

#### 16. ¿Qué afirmaciones sobre la siguiente clase son correctas? (Elija todas las que correspondan)

```java
 public class Pez {
    int branquias = 0, double peso = 2; // Linea 2 
    { int aletas = branquias; } // Linea 3 
    void imprimir(int longitud = 3) { // Linea 4
    System.out.println(branquias); 
    System.out.println(peso); 
    System.out.println(aletas); // Linea 7
    System.out.println(longitud); 
    } }
```

1. [X] A. La línea 2 contiene un error del compilador.
1. [ ] B. La línea 3 contiene un error del compilador.
1. [x] C. La línea 4 contiene un error del compilador.
1. [x] D. La línea 7 contiene un error del compilador.
1. [ ] E. El código imprime 0.
1. [ ] F. El código imprime 2.0.
1. [ ] G. El código imprime 2.
1. [ ] H. El código imprime 3.

Respuesta A, C, D

Explicacion

- La linea 2 contiene un error del compilador porque la variable peso es declarada como double y no se puede declarar multiples variables de duferentes tipos en una sola linea
- La linea 4 contiene un error del compilador porque el parametro longitud no se le puede asignar un valor por defecto
- La linea 7 contiene un error del compilador porque la variable aletas es declarada dentro de un bloque y no es accesible fuera de el

#### 17. ¿Qué afirmaciones sobre las clases y sus miembros son correctas? (Elija todas las que correspondan)

1. [X] A. No se puede hacer referencia a una variable declarada en un bucle fuera del bucle.
1. [ ] B. No se puede declarar una variable en un bloque inicializador de instancia.
1. [ ] C. Un argumento de constructor está dentro del alcance de la vida de la instancia de la clase para la cual
se define.
1. [ ] D. Un método de instancia solo puede acceder a variables de instancia declaradas antes de la instancia
declaración del método.
1. [X] E. Se puede declarar una variable en un bloque inicializador de instancia, pero no se puede hacer referencia a ella fuera del bloque.
1. [X] F. Un constructor puede acceder a todas las variables de instancia.
1. [X] G. Un método de instancia puede acceder a todas las variables de instancia.

Respuesta: A, E, F, G

Explicacion:

- No se puede hacer referencia a una variable declarada en un bucle fuera del bucle.
- Se puede declarar una variable en un bloque inicializador de instancia, pero no se puede hacer referencia a ella fuera del bloque.
-

#### 18. ¿Qué afirmaciones sobre el siguiente fragmento de código son correctas? (Elija todas las que correspondan)

```java
 var ardilla = new Object(); //3
 int capibara = 2, ratón, castor = -1;  //4
 char carbonizada = -1; //5
 ardilla = ""; //6
 castor = capibara; //7
 System.out.println(capibara); //8
 System.out.println(ratón); //9
 System.out.println(castor);  //10
 System.out.println(carbonizada); //11

```

1. [ ] A. El código imprime 2.
1. [ ] B. El código imprime -1.
1. [ ] C. El código imprime la cadena vacía.
1. [ ] D. El código imprime: null.
1. [ ] E. La línea 4 contiene un error del compilador.
1. [x] F. La línea 5 contiene un error del compilador.
1. [x] G. La línea 9 contiene un error del compilador.
1. [ ] H. La línea 10 contiene un error del compilador.

Respuesta: F, G

Explicacion:

- La linea 5 contiene un error del compilador porque la variable carbonizada es de tipo char y se le esta asignando un int negativo
- La linea 9 contiene un error del compilador porque la variable raton no es inicializada y se le esta asignando a un metodo println

#### 19. Suponiendo que se compila la siguiente clase, ¿cuántas variables definidas en la clase o método? ¿Están dentro del alcance en la línea marcada // ALCANCE en la línea 14?

```java

public class Camello {
 { int pelos = 3_000_0; }
 long agua, aire=2;
 boolean dosJorobas = true;
 public void salivazo(float distancia) {
    var ruta = "";
    { double dientes = 32 + distancia++; }
    while(agua > 0) {
        int edad = dosJorobas? 1: 2;
        short i = -1;
        for(i=0; i<10; i++) {
            var Privado = 2;
        }
        // ALCANCE
    } 
  }  
}
```

1. [ ] A.2
1. [ ] B.3
1. [ ] C.4
1. [ ] D.5
1. [ ] E.6
1. [x] F.7
1. [ ] G. Ninguna de las anteriores

Respuesta: F

Explicacion:

- La variable agua es una variable de instancia y esta dentro del alcance
- La variable aire es una variable de instancia y esta dentro del alcance
- La variable dosJorobas es una variable de instancia y esta dentro del alcance
- La variable ruta es una variable local y esta dentro del alcance
- La variable edad es una variable local y esta dentro del alcance
- La variable i es una variable local y esta dentro del alcance

#### 20.  ¿Cuál es el resultado de ejecutar la siguiente clase?

```java
 public class Salmon {
    int cuenta;
    { System.out.print(cuenta+"-"); } // 3
    {cuenta++; } // 4
    
    public Salmon() {
        cuenta = 4;
        System.out.print(2+"-"); 8: 
    }
    public static void main (String [] argumentos) {
        System.out.print(7+"-");
        var s = new Salmon();
        System.out.print(s.cuenta+"-"); 
     } 
}
```

1. [ ] A.7-0-2-1-
1. [ ] B. 7-0-1-
1. [ ] C. 0-7-2-1-
1. [X] D. 7-0-2-4-
1. [ ] E. 0-7-1-
1. [ ] F. La clase no compila por culpa de la línea 3.
1. [ ] G. La clase no se compila debido a la línea 4.
1. [ ] H. Ninguna de las anteriores.

Respuesta D

Explicacion:

- La clase compila y se ejecuta correctamente
- La variable cuenta es inicializada con 0
- La variable cuenta es impresa con el valor 0
- La variable cuenta es impresa con el valor 4
- Se imprime 7-0-2-4

#### 21. ¿Qué afirmaciones sobre el siguiente programa son correctas? (Elija todas las que correspondan)

```java

 public class Oso {
     private Oso panda;
     protected void finalize() {}
     private void rugido(Oso b) {
            System.out.println ("¡Rugido!");
            panda = b;
     }
     public static void main (String [] argumentos) {
                Oso marrón = nuevo Oso(); // 9
                Oso polar = nuevo Oso(); // 10
                marrón.rugido(polar); // 11
                polar = null; // 12
                marrón = null; // 13
                System.gc(); // 14
        } 
}
```

1. [x] A. El objeto creado en la línea 9 es elegible para la recolección de basura después de la línea 13.
1. [ ] B. El objeto creado en la línea 9 es elegible para la recolección de basura después de la línea 14.
1. [ ] C. El objeto creado en la línea 10 es elegible para la recolección de basura después de la línea 12.
1. [x] D. El objeto creado en la línea 10 es elegible para la recolección de basura después de la línea 13.
1. [ ] E. Se garantiza que la recolección de basura se ejecutará.
1. [x] F. La recolección de basura puede ejecutarse o no.
1. [ ] G. Se garantiza que la recolección de basura no se ejecutará.
1. [ ] H. El código no se compila.

Respuesta: A, D, F

Explicacion:

- El objeto creado en la línea 9 es elegible para la recolección de basura después de la línea 13.
- El objeto creado en la línea 10 es elegible para la recolección de basura después de la línea 13.
- La recolección de basura puede ejecutarse o no.

#### 22. ¿Cuáles de las siguientes son declaraciones de variables de instancia válidas? (Elija todas las que correspondan)

1. [ ] A. var _= 6000_.0;
1. [ ] B. var null = 6_000;
1. [ ] C. var $_= 6_000;
1. [ ] D. var $2 = 6_000f;
1. [ ] E. var var = 3_0_00.0;
1. [ ] F. var #CONS = 2_000.0;
1. [ ] G. var %C = 6_000_L;
1. [x] H. Ninguna de las anteriores

Respuesta: H

Explicacion:

- Ninguna declaracion es correcta por que var no puede ser usado como nombre de variable de instancia
