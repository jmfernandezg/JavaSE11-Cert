# APIS Principales de Java

- Una API es un conjunto de clases y metodos que proveen una funcionalidad especifica.
- Java tiene muchas API's que proveen funcionalidad para tareas comunes.
- Las API's son organizadas en paquetes.
  - `java.lang` es el paquete mas comun.
- String y StringBuilder estan en `java.lang` son usados en casi todos los programas para manipular texto.
- Una List, Set, Map, y ArrayList son usados en casi todos los programas para almacenar y manipular grupos datos.

## Creando y Manipulando Strings

- La clase de String es usada para crear y manipular Strings.
- Es inmutable, lo que significa que una vez que un String es creado, no puede ser cambiado.
- El metodo main() es el punto de entrada de un programa Java y requiere un array de Strings como parametro.
- Un string es un grupo de caracteres.
  - Ejemplo: "Hello World"
- Puede tambien asignarse con la palabra reservada `new`:
  - `String name = new String("Hello World");`
- Implementa la interfaz `CharSequence` que significa que puede ser tratado como un grupo de caracteres.
  - La interfaz CharSequence es implementada por String, StringBuilder, y StringBuffer.

### Concatenacion

- La concatenacion es la union de dos o mas Strings.
- El operador de concatenacion es el signo `+`.
- El operador de concatenacion puede ser usado para concatenar un String con cualquier otro tipo de dato.
- El operador de concatenacion puede ser usado para concatenar un String con otro String.
- El operador de concatenacion puede ser usado para concatenar un String con un StringBuilder.
- El operador de concatenacion puede ser usado para concatenar un String con un StringBuffer.
- El operador de concatenacion puede ser usado para concatenar un String con un char.
- El operador de concatenacion puede ser usado para concatenar un String con un int.
- El resultado de la concatenacion es un nuevo String.
- La expresion de concatenacion es evaluada de izquierda a derecha.

Ejemplo:

```java

// Concatenacion de String con String
String name = "Juan";
String lastName = "Perez";
String fullName = name + lastName;
System.out.println(fullName);  

// Concatenacion de String con int
String name = "Juan";
int age = 30;
String fullName = name + age;
System.out.println(fullName); // Juan30

// La suma de un String con un int es un String
System.out.println(1 + 3 + "Hello"); // 4Hello 
System.out.println("Hello" + 1 + 3); // Hello13

/// Tambien es posible usar += para concatenar

String name = "Juan";
name += " Perez";
System.out.println(name); // Juan Perez

// Tambien es posible concatenar numeros

String nombre = "Juan";
int edad = 30;
String nombreCompleto = nombre += edad;
System.out.println(nombreCompleto); // Juan30

```

### Inmutabilidad

- Un objeto inmutable es un objeto cuyo estado no puede ser cambiado despues de ser creado.
- Un String es inmutable.
- Las clases inmutables son finales, lo que significa que no pueden ser extendidas.

### Metodos Importantes

- Un String es una sequencia de caracteres, que iniciando en 0, puede ser accedido por su indice.

#### length()

- El metodo length() retorna el numero de caracteres en un String.
- El metodo length() retorna un int.
- El metodo length() es usado para iterar sobre un String.

Ejemplo:

```java

String name = "Juan";
System.out.println(name.length()); // 4

```

#### charAt()

- El metodo charAt() retorna el caracter en el indice especificado.
- El metodo charAt() retorna un char.
- Si el indice especificado esta fuera del rango, se lanza una excepcion `StringIndexOutOfBoundsException`.

Ejemplo:

```java

String name = "Juan";
System.out.println(name.charAt(0)); // J

// Fuera de rango

String name = "Juan";
System.out.println(name.charAt(4)); // StringIndexOutOfBoundsException


```

#### indexOf()

- El metodo indexOf() retorna el indice de la primera ocurrencia del caracter especificado.
- El metodo indexOf() retorna un int.
- Si el caracter especificado no es encontrado, el metodo retorna -1.
- El metodo indexOf() puede ser usado para buscar un caracter en un String.
- El metodo indexOf() puede ser usado para buscar un String en un String.
- Puede iniciar la busqueda desde un indice especificado.

Ejemplo:

```java


String name = "Juan";
System.out.println(name.indexOf('a')); // 1

String name = "Juan";
System.out.println(name.indexOf('z')); // -1

String name = "Parangaricutiro";

// Buscando un caracter desde un indice especificado
System.out.println(name.indexOf('a', 2)); // 3

// Buscando un String
System.out.println(name.indexOf("ang")); // 3


```

#### substring()

- El metodo substring() retorna un nuevo String que es una subsecuencia del String original.
- El metodo substring() retorna un String.
- El metodo substring() puede ser usado para extraer una subsecuencia de un String.
- El metodo substring() puede ser usado para extraer una subsecuencia de un String desde un indice especificado.
- El indice inicia en cero y es inclusivo.
- El indice final es exclusivo.

##### Tabla de indices de substring()

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| P   | a   | r   | a   | n   | g   | a   | r   | i   | c   |

- Se puede visualizar como:
  - El indice 0 es la primera letra, P.
  - El indice 9 se detieneen la letra i
  - El indice 10 es el final del String.

Ejemplo:

```java


String name = "Parangaricutiro";
System.out.println(name.substring(0, 3)); // Par

String name = "Parangaricutiro";
System.out.println(name.substring(3)); // angaricutiro



```

#### toLowerCase() y toUpperCase()

- El metodo toLowerCase() retorna un nuevo String con todos los caracteres en minusculas.
- El metodo toUpperCase() retorna un nuevo String con todos los caracteres en mayusculas.
- El metodo toLowerCase() y toUpperCase() retornan un String.
- El metodo toLowerCase() y toUpperCase() pueden ser usados para comparar Strings sin importar si estan en mayusculas o minusculas.
- El metodo toLowerCase() y toUpperCase() pueden ser usados para convertir un String a minusculas o mayusculas.

 Eejemplo:

```java

String name = "Juan";

// Comparando Strings sin importar si estan en mayusculas o minusculas

if (name.toLowerCase().equals("juan")) {
  System.out.println("Son iguales");
}

// Convirtiendo un String a minusculas o mayusculas

String name = "Juan";

System.out.println(name.toLowerCase()); // juan
System.out.println(name.toUpperCase()); // JUAN

```

#### equals() y equalsIgnoreCase()

- El metodo equals() compara dos Strings y retorna true si son iguales.
- El metodo equals() compara dos Strings y retorna false si son diferentes.
- El metodo equals() es sensible a mayusculas y minusculas.
- El metodo equalsIgnoreCase() compara dos Strings y retorna true si son iguales.
- El metodo equalsIgnoreCase() compara dos Strings y retorna false si son diferentes.
- El metodo equalsIgnoreCase() no es sensible a mayusculas y minusculas.

Ejemplo:

```java

String name = "Salma";

if (name.equals("Salma")) {
  System.out.println("Son iguales");
}

String name = "Salma";

if (name.equalsIgnoreCase("salma")) {
  System.out.println("Son iguales");
}




```

#### startsWith() y endsWith()

- El metodo startsWith() retorna true si el String inicia con el prefijo especificado.
- El metodo startsWith() retorna false si el String no inicia con el prefijo especificado.
- El metodo startsWith() es sensible a mayusculas y minusculas.
- El metodo endsWith() retorna true si el String termina con el sufijo especificado.
- El metodo endsWith() retorna false si el String no termina con el sufijo especificado.
- El metodo endsWith() es sensible a mayusculas y minusculas.
- El metodo startsWith() y endsWith() retornan un boolean.
- El metodo startsWith() y endsWith() pueden ser usados para filtrar Strings.

Ejemplo:

```java

String name = "Salma";

if (name.startsWith("Sal")) {
  System.out.println("Inicia con Sal");
}

String name = "Salma";

if (name.endsWith("ma")) {
  System.out.println("Termina con ma");
}

```

#### replace()

- El metodo replace() retorna un nuevo String con todas las ocurrencias del caracter especificado reemplazadas por el caracter especificado.
- El metodo replace() retorna un String.
- El metodo replace() puede ser usado para reemplazar un caracter en un String.

Ejemplo:

```java

String name = "Salma";

System.out.println(name.replace('a', 'o')); // Solmo

```

#### contains()

- El metodo contains() retorna true si el String contiene la secuencia de caracteres especificada.
- La comparacion es sensible a mayusculas y minusculas.
- El metodo contains() retorna un boolean.
- El metodo contains() puede ser usado para filtrar Strings.
- El metodo contains() puede ser usado para buscar una secuencia de caracteres en un String.

Ejemplo:

```java

String name = "Salma";

if (name.contains("al")) {
  System.out.println("Contiene al");
} else {
  System.out.println("No contiene al");
}

```

#### trim(), strip(), stripLeading(), stripTrailing()

- El metodo trim() retorna un nuevo String con los espacios en blanco removidos del inicio y final del String.
- El metodo trim() retorna un String.
- El metodo trim() puede ser usado para remover espacios en blanco del inicio y final de un String.
- El metodo strip() retorna un nuevo String con los espacios en blanco removidos del inicio y final del String.
  - El metodo strip() fue introducido en Java 11.
  - El metodo es parecido a trim() pero tiene sopoerte para Unicode.
- El metodo strip() retorna un String.
- El metodo stripLeading() retorna un nuevo String con los espacios en blanco removidos del inicio del String.
  - El metodo stripLeading() fue introducido en Java 11.
  - El metodo es parecido a strip() pero solo remueve los espacios en blanco del inicio.
- El metodo stripLeading() retorna un String.
- El metodo stripTrailing() retorna un nuevo String con los espacios en blanco removidos del final del String.
  - El metodo stripTrailing() fue introducido en Java 11.
  - El metodo es parecido a strip() pero solo remueve los espacios en blanco del final.

Ejemplo:

```java

String name = " Salma ";

System.out.println(name.trim()); // "Salma"

String name = " Salma ";

System.out.println(name.strip()); // "Salma"

String name = " Salma ";

System.out.println(name.stripLeading()); // "Salma "

String name = " Salma ";

System.out.println(name.stripTrailing()); // " Salma"

```

#### intern()

- El metodo intern() retorna un String que tiene el mismo valor que el String original pero que esta en el String pool.

Ejemplo:

```java

String name = "Salma";

String name2 = new String("Salma");

System.out.println(name == name2); // false

String name3 = "Salma";

System.out.println(name == name3); // true

String name4 = name2.intern();

System.out.println(name == name4); // true

```

### Encadenacion de Metodos

- Es comun encadenar metodos en Java.
- El resultado de un metodo es pasado como parametro al siguiente metodo.
- Cada resultado es un nuevo objeto.
- Se debe de asignar el resultado a una variable para poder usarlo.

Ejemplo:

```java

String name = "Salma";

String nombreCompleto = name.concat(" Perez").toUpperCase().trim();

System.out.println(nombreCompleto); // SALMA PEREZ

```

## Utilizando la clase StringBuilder

- Cada vez que se concatena un String, se crea un nuevo objeto.
- Esto es ineficiente, especialmente si se esta concatenando en un loop.
- La clase StringBuilder es usada para crear y manipular Strings.
- La clase StringBuilder es mutable, lo que significa que puede ser cambiada despues de ser creada.

Ejemplo:

```java

StringBuilder sb = new StringBuilder("Hola");
sb.append(" Mundo");
System.out.println(sb); // Hola Mundo

```

### Mutabilidad y Encadenacion

- Cuando se encadenan metodos en un String, se crea un nuevo objeto cada vez y el objeto original no es cambiado. El objeto debe de ser asignado a una variable para poder usarlo.
- En un StringBuilder, el objeto original es cambiado cada vez que se enString un metodo.
- El objeto original no es cambiado cuando se enString un metodo en un String.

Ejemplo:

```java

StringBuilder princesas = "cenicienta";

princesas.append(" blanca nieves");
princesas.append(" bella durmiente");
princesas.append(" rapunzel");

System.out.println(princesas); // cenicienta blanca nieves bella durmiente rapunzel

```

### Creando un String Builder

- Es posible crear un StringBuilder sin especificar un valor inicial.
- El valor inicial por defecto es 16.
- El valor inicial puede ser especificado como parametro.
- El valor inicial debe de ser mayor a cero.
- El valor inicial puede ser especificado como un String.
- El valor inicial puede ser especificado como un CharSequence.
- El valor inicial puede ser especificado como un StringBuffer.
- El valor inicial puede ser especificado como un StringBuilder.

Ejemplo:

```java


StringBuilder sb = new StringBuilder();
System.out.println(sb.capacity()); // 16

StringBuilder sb = new StringBuilder(20);
System.out.println(sb.capacity()); // 20
System.out.println(sb.length()); // 0

StringBuilder sb = new StringBuilder("Hola");
System.out.println(sb); // Hola

StringBuilder sb = new StringBuilder(new StringBuffer("Hola"));
System.out.println(sb); // Hola

StringBuilder sb = new StringBuilder(new StringBuilder("Hola"));
System.out.println(sb); // Hola

```

### Metodos Importantes

- La clase StringBuilder es usada para crear y manipular Strings.

#### charAt(), indexOf(), length(), substring()

- Funcionan igual que en un String.

Ejemplo:

```java

StringBuilder sb = new StringBuilder("Hola Mundo");

System.out.println(sb.charAt(0)); // H
System.out.println(sb.indexOf("Mundo")); // 5
System.out.println(sb.length()); // 10
System.out.println(sb.substring(0, 4)); // Hola

```

#### append()

- El metodo append() retorna un StringBuilder.
- El metodo append() puede ser usado para concatenar un String, char, int, long, float, double, boolean, Object, char[], CharSequence, StringBuffer, StringBuilder.

Ejemplo:

```java

StringBuilder sb = new StringBuilder("Hola");

sb.append(" Mundo");
sb.append('!');
sb.append(",")
sb.append(1);
sb.append(",")
sb.append(1.0);
sb.append(",")
sb.append(true);
sb.append(",")
sb.append(new Object());
sb.append(",")
sb.append(new char[] {'a', 'b', 'c'});
sb.append(",")
sb.append(new StringBuffer("Hola"));
sb.append(",")
sb.append(new StringBuilder("Hola"));


System.out.println(sb); // Hola Mundo!,1,1.0,truejava.lang.Object@2f4d3709,abc,Hola,Hola

```

#### delete() y deleteCharAt()

- El metodo delete() retorna un StringBuilder.
- El metodo delete() puede ser usado para eliminar una secuencia de caracteres.
  - El indice final es exclusivo.
  - El indice inicia en cero.
  - Si el indice especificado esta fuera de rango, no se lanza una excepcion, se elimina hasta el final del String.
- El metodo deleteCharAt() retorna un StringBuilder.
- El metodo deleteCharAt() puede ser usado para eliminar un caracter en un indice especificado.
  - Si el indice especificado esta fuera de rango, se lanza una excepcion `StringIndexOutOfBoundsException`.

Ejemplo:

```java

StringBuilder sb = new StringBuilder("Hola Mundo!");

sb.delete(0, 5);

System.out.println(sb); // Mundo!

sb.delete(0, 100);

System.out.println(sb); // ""

StringBuilder sb = new StringBuilder("Hola Mundo!");

sb.deleteCharAt(0);

System.out.println(sb); // ola Mundo!

sb.deleteCharAt(100); // StringIndexOutOfBoundsException

```

#### replace()

- El metodo replace() retorna un StringBuilder.
- Funciona diferente a un String.
- El metodo replace() puede ser usado para reemplazar una secuencia de caracteres por otra secuencia de caracteres.
  - El indice final es exclusivo.
  - El indice inicia en cero.
  - Si el indice inicial especificado es negativo, se lanza una excepcion `IndexOutOfBoundsException`.
  - Si el indice final es menor al indice inicial, se lanza una excepcion `IndexOutOfBoundsException`.

Ejemplo:

```java

StringBuilder sb = new StringBuilder("Hola Mundo!");

sb.replace(0, 5, "Adios");

System.out.println(sb); // Adios Mundo!

sb.replace(0, 100, "Adios");

System.out.println(sb); // Adios

sb.replace(-1, 5, "Adios"); // IndexOutOfBoundsException

sb.replace(0, 5, "Adios"); // IndexOutOfBoundsException

```

#### reverse()

- El metodo reverse() retorna un StringBuilder.
- El metodo reverse() puede ser usado para invertir un String.

Ejemplo:

```java

StringBuilder sb = new StringBuilder("Hola Mundo!");

sb.reverse();

System.out.println(sb); // !odnuM aloH

```

#### toString()

- El metodo toString() retorna un String.
- El metodo toString() puede ser usado para convertir un StringBuilder a un String.

Ejemplo:

```java

StringBuilder sb = new StringBuilder("Hola Mundo!");

String s = sb.toString();

System.out.println(s); // Hola Mundo!

```

## Entendiendo Igualidad

- La igualdad es la relacion entre dos objetos.
- Dos objetos son iguales si tienen el mismo valor.
- Dos objetos son iguales si apuntan a la misma referencia.
- Dos objetos son iguales si tienen el mismo hashcode.
- Dos objetos son iguales si tienen el mismo valor y el mismo hashcode.

### Comparando con equals() y ==

- El operador == compara dos referencias y retorna true si apuntan al mismo objeto.
- El metodo equals() compara dos objetos y retorna true si tienen el mismo valor.
- El metodo equals() es usado para comparar objetos.
- En un StringBUilder, el metodo equals() compara dos objetos y retorna true si tienen la misma referencia

Ejemplo:

```java

String name = "Salma";
String name2 = "Salma";

System.out.println(name == name2); // true

String name = "Salma";
String name2 = new String("Salma");

System.out.println(name == name2); // false

String name = "Salma";
String name2 = new String("Salma");

System.out.println(name.equals(name2)); // true

StringBuilder sb = new StringBuilder("Salma");
StringBuilder sb2 = new StringBuilder("Salma");

System.out.println(sb.equals(sb2)); // false

```

### El pool de Strings

- El pool de Strings es un area de memoria en el heap que almacena Strings.
- Para ahorrar memoria, Java reusa Strings en el pool de Strings.
- Cuando se crea un String, Java busca en el pool de Strings para ver si ya existe.
- Si el String ya existe, Java reusa el String.
- El String Pool es tambien conocido como String Interning.

Ejemplo:

```java

String name = "Salma";
String name2 = "Salma";

System.out.println(name == name2); // true

String name = "Salma";
String name2 = new String("Salma");

System.out.println(name == name2); // false

String name = "Salma";
String name2 = new String("Salma").intern();

System.out.println(name == name2); // true

String numeroUno = "numero" + 1;
String segundo = "n" + "u" + "m" + "e" + "r" + "o" + 1;
String tercero = "n" + "u" + "m" + "e" + "r" + "o" + new String("1");

System.out.println(numeroUno == segundo); // true
System.out.println(numeroUno == tercero); // false
System.out.println(segundo == tercero.intern); // true

```

## Entendiendo Arreglos

- Un arreglo es un grupo de elementos del mismo tipo.
- Es un espacio de memoria contiguo en el heap.
- Un arreglo se declara especificando el tipo de dato y el numero de elementos.
- Se utilizan corchetes para declarar un arreglo.

Ejemplo:

```java

int[] numeros = new int[3];

System.out.println(numeros.length); // 3

```

### Creando Arreglos de Primitivos

- Un arreglo de primitivos es un grupo de elementos del mismo tipo.
- Cuando se especifica el numero de elementos, se crea un espacio de memoria contiguo en el heap.
- Los elementos son inicializados con el valor por defecto del tipo de dato.

Ejemplo:

```java

int[] numeros = new int[3];

System.out.println(numeros.length); // 3

forEach (int numero : numeros) {
  System.out.println(numero); // 0 0 0
}

```

- Es posible crear arreglos anonimos.
- Son llmados anonimos por que no se especifica el tipo ni la dimension.

Ejemplo:

```java

int[] numeros = {1, 2, 3};

System.out.println(numeros.length); // 3

forEach (int numero : numeros) {
  System.out.println(numero); // 1 2 3
}

```

- Es posible poner los corchete despues del nombre de la variable.
- El espacio es opcional.

Ejemplo:

```java

int numeros[] = {1, 2, 3};

int [] numeros = {1, 2, 3};

int[] numeros = {1, 2, 3};

```

- Es posible declarar un arreglo sin inicializarlo.
- Es posible declarar multiples variables de arreglo en una sola linea
  - Si los corchetes estan en el tipo, las variables seran arreglos
  - Si los corchetes estan en el nombre, solo la primera variable sera un arreglo

Ejemplo:

```java

int[] numeros, numeros2; // numeros y numeros2 son arreglos

int numeros[], numeros2; // numeros es un arreglo, numeros2 es un int

```

### Creando Arreglos de Referencias

- Un arreglo de referencias es un grupo de elementos del mismo tipo.
- Un arreglo es un objeto, por lo que las referencias son inicializadas con null.

Ejemplo:

```java

String[] nombres = new String[3];

System.out.println(nombres.length); // 3

forEach (String nombre : nombres) {
  System.out.println(nombre); // null null null
}

// Casting de tipos de un arreglo

String[] nombres = new String[3];
Object[] objetos = nombres;

String[] nombres2 = (String[]) objetos;
nombres2[0] = "Salma";
objetos[1] = new StringBuilder("Salma");


```

### Usando Arreglos

- El indice de un arreglo inicia en cero.
- El indice final es el numero de elementos menos uno.
- El metodo length no lleva parentesis.
- El metodo length retorna el numero de elementos en el arreglo.
- Para acceder a un elemento se utiliza el indice entre corchetes.
- Para iterar sobre un arreglo se utiliza un ciclo for.
- Si se intenta acceder a un indice fuera de rango, se lanza una excepcion `ArrayIndexOutOfBoundsException`.

Ejemplo:

```java

int[] numeros = {1, 2, 3};

System.out.println(numeros.length); // 3

System.out.println(numeros[0]); // 1

for (int i = 0; i < numeros.length; i++) {
  System.out.println(numeros[i]); // 1 2 3
}

// Fuera de rango

int[] numeros = {1, 2, 3};

System.out.println(numeros[3]); // ArrayIndexOutOfBoundsException

```

### Ordenando Arreglos

- El metodo sort() de la clase Arrays es usado para ordenar arreglos.
- La clase Arrays es usada para manipular arreglos.
- Se importa con `import java.util.Arrays;`

Ejemplo:

```java
import java.util.Arrays;

int[] numeros = {3, 2, 1};

Arrays.sort(numeros);

for (int i = 0; i < numeros.length; i++) {
  System.out.println(numeros[i]); // 1 2 3
}

// Tambien es posible usar Arrays.toString()
int[] numeros = {3, 2, 1};

System.out.println(Arrays.toString(numeros)); // [3, 2, 1]

// Tambien es posible usar un for each

int[] numeros = {3, 2, 1};

for (int numero : numeros) {
  System.out.println(numero); // 3 2 1
}

```

### Buscando

- Java provee de una forma conveniente para buscar, si el arreglo esta ordenado.

#### Tabla de reglas de busqueda binaria

| Escenario                       | Resultado                                    |
| ------------------------------- | -------------------------------------------- |
| Si el elemento es encontrado    | El indice del elemento                       |
| Si el elemento no es encontrado | El indice donde el elemento deberia de estar |
| Si el arreglo no esta ordenado  | El resultado es impredecible                 |

Ejemlo:

```java

int[] numeros = {1, 2, 3};

System.out.println(Arrays.binarySearch(numeros, 2)); // 1

int[] letras = {'a', 'b', 'c', 'f' };

System.out.println(Arrays.binarySearch(letras, 'd')); // -4

int[] numeros = {3, 2, 1};

System.out.println(Arrays.binarySearch(numeros, 2)); // -2

```

### Comparando

- Se pueden compara dos arreglos para determinar si son iguales o no.

#### compare()

- El metodo compare() de la clase Arrays es usado para comparar dos arreglos.
- Existen reglas para el valor de retorno
  - Un numero negativo si el primer arreglo es menor que el segundo arreglo.
  - Cero si los arreglos son iguales.
  - Un numero positivo si el primer arreglo es mayor que el segundo arreglo.

Ejemplo:

```java

int[] numeros = {1, 2, 3};

int[] numeros2 = {1, 2, 3};

int [] numeros3 = {1, 2, 4};

// iguales
System.out.println(Arrays.compare(numeros, numeros2)); // 0

// menor
System.out.println(Arrays.compare(numeros, numeros3)); // -1

// mayor
System.out.println(Arrays.compare(numeros3, numeros)); // 1

```

- Si los arreglos son de la misma longitud y tienen las mismas referencias en los mismos indices, entonces son iguales.
- Si todos los elementos son iguales, pero el segundo arreglo es mas largo, entonces el primer arreglo es menor.
  - Regresa un numero negativo.
- Si todos los elementos son iguales, pero el primer arreglo es mas largo, entonces el primer arreglo es mayor.
  - Regresa un numero positivo.
- Si el primer elemento diferente es menor en el primer arreglo, entonces el primer arreglo es menor.
  - Regresa un numero negativo.
  - El numero es el resultado de restar el primer elemento diferente del primer arreglo con el primer elemento diferente del segundo arreglo.
  - El numero es negativo.
- Si el primer elemento diferente es mayor en el primer arreglo, entonces el primer arreglo es mayor.
  - Regresa un numero positivo.
  - El numero es el resultado de restar el primer elemento diferente del primer arreglo con el primer elemento diferente del segundo arreglo.
  - El numero es positivo.

#### Que significa que un numero sea menor

- Se usa el metodo `compareTo()` para determinar si un arreglo es menor que otro.
- El valor `null` es menor que cualquier otro valor
- Para valores numericos, el valor mas pequeño es menor.
- Para valores de caracteres, el valor mas pequeño es menor.
  - Si uno es el prefijo del otro, entonces el mas corto es menor.
  - Los numeros son menores que las letras.
  - Las letras mayusculas son menores que las minusculas.
- Los tipos a comparar deben de ser compatibles.
  - Si no son compatibles, se lanza una excepcion `ClassCastException`.

##### Tabla de comparacion de `Arrays.compare()`

| Primer Arreglo  | Segundo Arreglo  | Resultado | Razón                                        |
| --------------- | ---------------- | --------- | -------------------------------------------- |
| new int[] {1,2} | new int[] {1,2}  | 0         | Son iguales                                  |
| new int[] {1,2} | new int[] {1}    | 1         | El primer arreglo es tiene mas elementos     |
| new int[] {"a"} | new int[] {"aa"} | -1        | El primer elemento es un prefijo del segundo |
| new int[] {"a"} | new int[] {"A"}  | 32        | Mayusculas es menor que minusculas           |
| new int[] {"a"} | new int[] {null} | -1        | null siempre es menor                        |

#### mismatch()

- El metodo mismatch() de la clase Arrays es usado para determinar el indice del primer elemento diferente.
- Si los arreglos son iguales, el metodo regresa -1.
- Si los arreglos son diferentes, el metodo regresa el indice del primer elemento diferente.

##### Igualdad vs comparacion vs mismatch

| Metodo   | Igualdad | Diferentes |
| -------- | -------- | ---------- |
| equals   | true     | false      |
| compare  | 0        | != 0       |
| mismatch | -1       | >= 0       |

### Varargs

- Existen 3 formas de definir un arreglo
  - Con los corchetes despues del tipo de dato
  - Con los corchetes despues del nombre de la variable
  - Con varargs
- Es posible usar varargs para crear un arreglo

Ejemplo:

```java

public static void main(String[] args) {
  System.out.println(args.length); // 0
}

public static void main(String args[]) {
  System.out.println(args.length); // 0
}

public static void main(String... args) {
  System.out.println(args.length); // 0
}

```

- Los varargs se definen con tres puntos despues del tipo de dato.

### Arreglos Multidimensionales

- Son arreglos que contienen arreglos.

#### Creando Arreglos Multidimensionales

- Es posible crear arreglos multidimensionales con multiples corchetes.
- Es posible crear arreglos multidimensionales con multiples corchetes despues del nombre de la variable.
- Es posible crear arreglos multidimensionales con multiples corchetes despues del tipo de dato.
- Es posible crear arreglos multidimensionales con un corchete despues del tipo de dato y un corchete despues del nombre de la variable.

Ejemplo:

```java

// Despues del tipo de dato
int[][] numeros = new int[3][2];

// Despues del nombre de la variable
int numeros[][] = new int[3][];

// Despues del tipo de dato y despues del nombre de la variable
int[] numeros[] = new int[3][];

```

#### Usando Arreglos Multidimensionales

- Es posible acceder a un elemento de un arreglo multidimensional con multiples bucles

Ejemplo:

```java

int[][] numeros = {{1, 2}, {3, 4}, {5, 6}};

for (int i = 0; i < numeros.length; i++) {
  for (int j = 0; j < numeros[i].length; j++) {
    System.out.println(numeros[i][j]); // 1 2 3 4 5 6
  }
}

// Tambien es posible usar un foreach

int[][] numeros = {{1, 2}, {3, 4}, {5, 6}};

for (int[] numero : numeros) {
  for (int numero2 : numero) {
    System.out.println(numero2); // 1 2 3 4 5 6
  }
}

```

## Entendiendo ArrayList

- Un ArrayList es una lista de elementos del mismo tipo.
- Un arreglo no puede cambiar de tamaño.
- Un ArrayList puede cambiar de tamaño.

### Creando un ArrayList

- Existen 3 formas de crear un `ArrayList`
  - new ArrayList(): Crea un `ArrayList` vacio.
  - new ArrayList(int): Crea un `ArrayList` con la capacidad especificada.
  - new ArrayList(Collection): Crea un `ArrayList` con los elementos de la coleccion especificada.

- Es posible crear un `ArrayList` con un tipo de dato especifico.
- El tipo de dato especificado es el tipo de dato de los elementos del `ArrayList`.
  - ArrayList<String> nombres = new ArrayList<String>();
  - ArrayList<String> nombres = new ArrayList<>();

- Es posible usar var args para crear un `ArrayList`.
  - var nombres = new ArrayList<String>("Salma", "Perez");

Ejemplo:

```java

ArrayList<String> nombres = new ArrayList<String>();

ArrayList<String> nombres = new ArrayList<>();

var nombres = new ArrayList<String>("Salma", "Perez");
nombres.add("Salma");

for (String nombre : nombres) {
  System.out.println(nombre); // Salma Perez
}

// Tambien es posible declarar un arrayList con tipo de dato List 

List<String> nombres = new ArrayList<String>();

```

### Usando un ArrayList

- La firma de los metodos tiene una clase llamada E.
- E es el tipo de dato de los elementos del ArrayList.
- Si no se especifica el tipo de dato, se usa Object.

#### add()

- El metodo add() agrega un elemento al final del ArrayList.
  - El metodo `add(int index)` retorna un boolean.
- Es posible especificar el indice donde se va a agregar el elemento.
  - Si el indice especificado es mayor al numero de elementos, se lanza una excepcion `IndexOutOfBoundsException`.
  - Si el indice especificado es menor a cero, se lanza una excepcion `IndexOutOfBoundsException`.
  - Si el indice especificado es igual al numero de elementos, el elemento es agregado al final del ArrayList.
  - Si el indice especificado es menor al numero de elementos, el elemento es agregado en el indice especificado y los elementos son desplazados a la derecha.
  - `add(int index, E element)` retorna void.
- Si el arreglo no especifica un tipo de dato, se puede agregar cualquier tipo de dato.
- Si el arreglo especifica un tipo de dato, se puede agregar cualquier tipo de dato que sea compatible con el tipo de dato especificado.
- Si el arreglo especifica un tipo de dato, se puede agregar null.

Ejemplo:

```java

ArrayList<String> nombres = new ArrayList<String>();

nombres.add("Salma"); // true
nombres.add("Perez"); // true
nombres.add(0, "Hayek"); // void

nombres.add(100, "Hayek"); // IndexOutOfBoundsException

```

#### remove()

- El metodo remove() remueve un elemento del ArrayList.
  - El metodo `remove(E object)` retorna un boolean.
  - El metodo `remove(int index)` retorna el elemento removido.

Ejemplo:

```java

ArrayList<String> nombres = new ArrayList<String>();

nombres.add("Salma"); // true
nombres.add("Perez"); // true
nombres.add(0, "Hayek"); // void

nombres.remove("Salma"); // true

for (String nombre : nombres) {
  System.out.println(nombre); // Hayek Perez
}

nombres.remove(0); // Hayek

for (String nombre : nombres) {
  System.out.println(nombre); // Perez
}

```

#### set()

- El metodo set() reemplaza un elemento del ArrayList.
  - El metodo `set(int index, E element)` retorna el elemento reemplazado.
- Si el indice especificado es mayor al numero de elementos, se lanza una excepcion `IndexOutOfBoundsException`.

Ejemplo:

```java

ArrayList<String> nombres = new ArrayList<String>();

nombres.add("Salma"); // true

nombres.set(0, "Hayek"); // Salma

for (String nombre : nombres) {
  System.out.println(nombre); // Hayek
}

nombres.set(100, "Hayek"); // IndexOutOfBoundsException

```

#### isEmpty() y size()

- El metodo isEmpty() retorna true si el ArrayList esta vacio.
  - El metodo isEmpty() retorna un boolean.
- El metodo size() retorna el numero de elementos en el ArrayList.
  - El metodo size() retorna un int.

Ejemplo:

```java

ArrayList<String> avengers = new ArrayList<String>();

System.out.println(avengers.isEmpty()); // true

avengers.add("Iron Man");

System.out.println(avengers.isEmpty()); // false

System.out.println(avengers.size()); // 1

```

#### clear()

- El metodo clear() remueve todos los elementos del ArrayList.
- El metodo clear() retorna void.

Ejemplo:

```java

ArrayList<String> avengers = new ArrayList<String>();
avengers.add("Ant Man");
avengers.add("Iron Man");
avengers.add("Hulk");

System.out.println(avengers.size()); // 3

// iterar 
for (String s: avengers){
  System.out.println(s); // 
}

// remover todos los elementos
avengers.clear();

System.out.println(avengers.size()); // 0

```

#### contains()

- El metodo `contains()` revisa si un valor esta en el ArrayList.
  - El metodo `contains(Object object)` retorna un boolean.
- El metodo llama a `equals()` para comparar los elementos.

Ejemplo:

```java

ArrayList<String> avengers = new ArrayList<String>();

avengers.add("Hulk");
avengers.add("Captain America");

System.out.println(avengers.contains("Hulk")); // true

System.out.println(avengets.contains("Iron Man")) // false

```

#### equals()

- El metodo `equals()` compara dos ArrayList.
  - El metodo `equals()` retorna un boolean.

Ejemplo:

```java

ArrayList<String> planetas = new ArrayList<String>();
planetas.add("Mercurio");
planetas.add("Venus");

ArrayList<String> planetas2 = new ArrayList<String>();
planetas2.add("Mercurio");
planetas2.add("Venus");

System.out.println(planetas.equals(planetas2)); // true

```

### Clases de Envoltura

- Las clases de envoltura son usadas para convertir tipos primitivos en objetos.

#### Tabla de clases de envoltura

| Tipo primitivo | Clase de envoltura | Ejemplo de creacion  | Ejemplo de conversion    |
| -------------- | ------------------ | -------------------- | ------------------------ |
| boolean        | Boolean            | new Boolean(true)    | Boolean.valueOf(true)    |
| byte           | Byte               | new Byte((byte) 1)   | Byte.valueOf((byte) 1)   |
| short          | Short              | new Short((short) 1) | Short.valueOf((short) 1) |
| int            | Integer            | new Integer(1)       | Integer.valueOf(1)       |
| long           | Long               | new Long(1)          | Long.valueOf(1)          |
| float          | Float              | new Float(1.0)       | Float.valueOf(1.0)       |
| double         | Double             | new Double(1.0)      | Double.valueOf(1.0)      |
| char           | Character          | new Character('a')   | Character.valueOf('a')   |

- El metodo valueOf es preferido sobre el constructor.
- El metodo valueOf permite que se reutilicen objetos.
- El metodo valueOf retorna un objeto del tipo de dato especificado.
- Las clases de envoltorio pueden convertir su valor a un tipo primitivo.
- Las clases de envoltorio pueden convertir su valor a un String.
- Las clases de envoltorio pueden convertir un String a su valor.
  - Si el String no puede ser convertido, se lanza una excepcion `NumberFormatException`.

Ejemplo

```java

Integer i = Integer.valueOf(1);
int i2 = i.intValue();

// Convertir string

Integer i = Integer.valueOf("1");
int i2 = Integer.parseInt("1");

// Convertir a string

Integer i = Integer.valueOf(1);
String s = i.toString();


/// String que no puede ser convertido

Integer i = Integer.valueOf("a"); // NumberFormatException

```

##### Tabla de conversion a String

| Clase de Envoltura | Convertir de String a primitivo | Convertir String a Clase de Envoltura |
| ------------------ | ------------------------------- | ------------------------------------- |
| Boolean            | Boolean.parseBoolean("TRUE")    | Boolean.valueOf("TRUE")               |
| Byte               | Byte.parseByte("1")             | Byte.valueOf("1")                     |
| Short              | Short.parseShort("1")           | Short.valueOf("1")                    |
| Integer            | Integer.parseInt("1")           | Integer.valueOf("1")                  |
| Long               | Long.parseLong("1")             | Long.valueOf("1")                     |
| Float              | Float.parseFloat("1.0")         | Float.valueOf("1.0")                  |
| Double             | Double.parseDouble("1.0")       | Double.valueOf("1.0")                 |
| Character          | N/A                             | N/A                                   |

### Autoboxing y Unboxing

- Autoboxing es la conversion automatica de un tipo primitivo a un objeto.
- Unboxing es la conversion automatica de un objeto a un tipo primitivo.

Ejemplo:

```java

Integer i = 1; // Autoboxing

int i2 = i; // Unboxing

List<Integer> numeros = new ArrayList<Integer>();
numeros.add(1); // Autoboxing
numeros.add(Integer.valueOf(1)); // Autoboxing
numeros.remove(0); // Unboxing

// Si se trata de hacer unboxing sobre null, se lanza una excepcion NullPointerException
List<Integer> numeros = new ArrayList<Integer>();
numeros.add(null); 

int i = numeros.get(0); // NullPointerException


// El metodo remove no hace autoboxing

List<Integer> numeros = new ArrayList<Integer>();
numeros.add(1); // Autoboxing
numeros.add(Integer.valueOf(1)); // Autoboxing
numeros.remove(1); // No hace autoboxing


```

### Convirtiendo entre Arreglos y Listas

- Es posible convertir un arreglo a un ArrayList.
- Es posible convertir un ArrayList a un arreglo.
- El metodo `asList()` de la clase Arrays es usado para convertir un arreglo a un ArrayList.
- El metodo `toArray()` de la clase ArrayList es usado para convertir un ArrayList a un arreglo.

Ejemplo:

```java

String[] nombres = {"Salma", "Perez"};

List<String> nombres2 = Arrays.asList(nombres);

nombres2.set(0, "Hayek");

System.out.println(nombres[0]); // Hayek

// Convertir ArrayList a arreglo

List<String> planetas = new ArrayList<String>();
planetas.add("Mercurio");
planetas.add("Venus");
planetas.add("Tierra");

String[] planetas2 = planetas.toArray(new String[0]); 

for (String planeta : planetas2) {
  System.out.println(planeta); // Mercurio Venus Tierra
}

```

- Es posible crear una lista inmutable con `List.of()`.
- Una lista inmutable no puede ser modificada.
  - Si se intenta agregar un elemento, se lanza una excepcion `UnsupportedOperationException`.
  - Si se intenta remover un elemento, se lanza una excepcion `UnsupportedOperationException`.
  - Si se intenta reemplazar un elemento, se lanza una excepcion `UnsupportedOperationException`.

Ejemplo:

```java

List<String> planetas = List.of("Mercurio", "Venus", "Tierra");

planetas.add("Marte"); // UnsupportedOperationException

planetas.remove(0); // UnsupportedOperationException

planetas.set(0, "Marte"); // UnsupportedOperationException

```

### Usando varargs para crear una lista

- Es posible crear una lista con varargs.
- Los metodos que reciben varargs pueden recibir un arreglo o una lista.
-

Ejemplo:

```java

List<String> planetas = List.of("Mercurio", "Venus", "Tierra");

List<String> pajaros = Arrays.asList("Loro", "Aguila");

```

#### Tabla de Conversion de List y Array

| Tipo de dato                          | toArray() | asList()          | List.of()         |
| ------------------------------------- | --------- | ----------------- | ----------------- |
| Convertir desde                       | List      | Array (o varargs) | Array (o varargs) |
| Tipo Creado                           | Array     | List              | List              |
| Permite remover elementos             | No        | No                | No                |
| Permite cambiar valores               | Si        | Si                | No                |
| Valores cambiados afectan al original | No        | Si                | N/A               |

- No esta permitido cambiar el numero de elementos de un arreglo.

### Ordenando Listas

- El metodo `sort()` de la clase Collections es usado para ordenar listas.
- Es similar a `Arrays.sort()`.

## Creando Sets y Maps

- Sets y Maps son interfaces.

### Creando un Set

- Un Set es una coleccion de elementos unicos.
- Un set no esta ordenado, por lo que no tiene indice.
- Un set no permite elementos duplicados.
- Los metodos de un Set son:
  - add() - Agrega un elemento al Set. Retorna un boolean.
  - remove() - Remueve un elemento del Set. Retorna un boolean.
  - isEmpty() - Retorna true si el Set esta vacio. Retorna un boolean.
  - size() - Retorna el numero de elementos en el Set. Retorna un int.
  - clear() - Remueve todos los elementos del Set. Retorna void.
  - contains() - Retorna true si el Set contiene el elemento. Retorna un boolean.
  - equals() - Retorna true si el Set es igual al Set especificado. Retorna un boolean.
- Las clases mas comunes que implementan Set son:
  - HashSet: No esta ordenado.
  - TreeSet: Ordenado.
  - LinkedHashSet: Ordenado en el orden en que fueron agregados.

Ejemplo:

```java

Set<String> planetas = new HashSet<String>();

planetas.add("Mercurio"); // true
planetas.add("Venus"); // true
planetas.add("Tierra"); // true
planetas.add("Marte"); // true
planetas.add("Jupiter"); // true
planetas.add("Saturno"); // true
planetas.add("Urano"); // true
planetas.add("Neptuno"); // true

System.out.println(planetas.size()); // 8

planetas.add("Tierra"); // false

// Remover elementos

planetas.remove("Tierra"); // true
planetas.remove("Pluton"); // false

// Iterar

for (String planeta : planetas) {
  System.out.println(planeta); // Mercurio Venus Marte Jupiter Saturno Urano Neptuno
}

// Ordenar

Set<String> planetas = new TreeSet<String>();
planetas.add("Mercurio"); // true
planetas.add("Venus"); // true
planetas.add("Tierra"); // true
planetas.add("Marte"); // true
planetas.add("Jupiter"); // true

for (String planeta : planetas) {
  System.out.println(planeta); // Jupiter Marte Mercurio Tierra Venus
}

// Ordenar con LinkedHashSet

Set<String> planetas = new LinkedHashSet<String>();
planetas.add("Mercurio"); // true
planetas.add("Venus"); // true
planetas.add("Tierra"); // true
planetas.add("Marte"); // true
planetas.add("Jupiter"); // true

for (String planeta : planetas) {
  System.out.println(planeta); // Mercurio Venus Tierra Marte Jupiter
}

```

### Creando un Map

- Un Map es una coleccion de pares de llave y valor.
- La implementacion mas comun de Map es HashMap.

#### Metodos de un Map

| Metodo          | Descripcion                                                                                                                                        |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| put()           | Agrega un par de llave y valor al Map. Retorna el valor anterior asociado con la llave, o null si no habia ninguno.                                |
| get()           | Retorna el valor asociado con la llave especificada, o null si no hay ninguno.                                                                     |
| remove()        | Remueve el par de llave y valor asociado con la llave especificada. Retorna el valor asociado con la llave especificada, o null si no hay ninguno. |
| isEmpty()       | Retorna true si el Map esta vacio. Retorna un boolean.                                                                                             |
| size()          | Retorna el numero de pares de llave y valor en el Map. Retorna un int.                                                                             |
| clear()         | Remueve todos los pares de llave y valor del Map. Retorna void.                                                                                    |
| containsKey()   | Retorna true si el Map contiene la llave especificada. Retorna un boolean.                                                                         |
| containsValue() | Retorna true si el Map contiene el valor especificado. Retorna un boolean.                                                                         |
| keySet()        | Retorna un Set de las llaves en el Map. Retorna un Set.                                                                                            |
| values()        | Retorna una coleccion de los valores en el Map. Retorna una coleccion.                                                                             |
| entrySet()      | Retorna un Set de los pares de llave y valor en el Map. Retorna un Set.                                                                            |

- El metodo `put()` agrega un par de llave y valor al Map.
  - El metodo `put(K key, V value)` retorna el valor anterior asociado con la llave, o null si no habia ninguno.
- El metodo `get()` retorna el valor asociado con la llave especificada, o null si no hay ninguno.
  - El metodo `get(Object key)` retorna el valor asociado con la llave especificada, o null si no hay ninguno.
  - El metodo `getOrDefault(Object key, V defaultValue)` retorna el valor asociado con la llave especificada, o el valor por defecto si no hay ninguno.
- El metodo `remove()` remueve el par de llave y valor asociado con la llave especificada.
  - El metodo `remove(Object key)` retorna el valor asociado con la llave especificada, o null si no hay ninguno.
- El metodo `isEmpty()` retorna true si el Map esta vacio.
  - El metodo `isEmpty()` retorna un boolean.
- El metodo `size()` retorna el numero de pares de llave y valor en el Map.
  - El metodo `size()` retorna un int.
- El metodo `clear()` remueve todos los pares de llave y valor del Map.
  - El metodo `clear()` retorna void.
- El metodo `containsKey()` retorna true si el Map contiene la llave especificada.
  - El metodo `containsKey(Object key)` retorna un boolean.
- El metodo `containsValue()` retorna true si el Map contiene el valor especificado.
  - El metodo `containsValue(Object value)` retorna un boolean.
- El metodo `keySet()` retorna un Set de las llaves en el Map.
  - El metodo `keySet()` retorna un Set.
- El metodo `values()` retorna una coleccion de los valores en el Map.
  - El metodo `values()` retorna una coleccion.
- El metodo `entrySet()` retorna un Set de los pares de llave y valor en el Map.
  - El metodo `entrySet()` retorna un Set.
  - El metodo `entrySet()` retorna un Set de la interfaz Entry.
  - La interfaz Entry tiene los metodos `getKey()` y `getValue()`.
- El metodo `putAll()` agrega todos los pares de llave y valor de un Map al Map actual.
  - El metodo `putAll(Map<? extends K, ? extends V> m)` retorna void.
  - El metodo `putAll(Map<? extends K, ? extends V> m)` recibe un Map.
  - El metodo `putAll(Map<? extends K, ? extends V> m)` agrega todos los pares de llave y valor de un Map al Map actual.
  - El metodo `putAll(Map<? extends K, ? extends V> m)` sobreescribe los valores de las llaves que ya existen.
  
  Ejemplo:

```java

Map<String, String> planetas = new HashMap<String, String>();

planetas.put("Mercurio", "Mercuriano");
planetas.put("Venus", "Venusiano");
planetas.put("Tierra", "Terricola");
planetas.put("Marte", "Marciano");
planetas.put("Jupiter", "Jupiteriano");
planetas.put("Saturno", "Saturniano");
planetas.put("Urano", "Uraniano");
planetas.put("Neptuno", "Neptuniano");

// Metodos

System.out.println(planetas.size()); // 8

System.out.println(planetas.get("Tierra")); // Terricola

System.out.println(planetas.getOrDefault("Pluton", "Plutoniano")); // Plutoniano

System.out.println(planetas.remove("Tierra")); // Terricola

System.out.println(planetas.remove("Pluton")); // null

System.out.println(planetas.containsKey("Tierra")); // false

System.out.println(planetas.containsValue("Terricola")); // false

System.out.println(planetas.isEmpty()); // false

planetas.clear();

System.out.println(planetas.isEmpty()); // true

// Iterar

for (String planeta : planetas.keySet()) {
  System.out.println(planeta); // Mercurio Venus Marte Jupiter Saturno Urano Neptuno
}

for (String planeta : planetas.values()) {
  System.out.println(planeta); // Mercuriano Venusiano Marciano Jupiteriano Saturniano Uraniano Neptuniano
}

for (Map.Entry<String, String> planeta : planetas.entrySet()) {
  System.out.println(planeta.getKey() + " - " + planeta.getValue()); // Mercurio - Mercuriano Venus - Venusiano Marte - Marciano Jupiter - Jupiteriano Saturno - Saturniano Urano - Uraniano Neptuno - Neptuniano
}

// Ordenar

Map<String, String> planetas = new TreeMap<String, String>();

planetas.put("Mercurio", "Mercuriano");
planetas.put("Venus", "Venusiano");
planetas.put("Tierra", "Terricola");
planetas.put("Marte", "Marciano");
planetas.put("Jupiter", "Jupiteriano");

for (Map.Entry<String, String> planeta : planetas.entrySet()) {
  System.out.println(planeta.getKey() + " - " + planeta.getValue()); // Jupiter - Jupiteriano Marte - Marciano Mercurio - Mercuriano Tierra - Terricola Venus - Venusiano
}



// Ordenar con LinkedHashMap

Map<String, String> planetas = new LinkedHashMap<String, String>();

planetas.put("Mercurio", "Mercuriano");
planetas.put("Venus", "Venusiano");
planetas.put("Tierra", "Terricola");
planetas.put("Marte", "Marciano");
planetas.put("Jupiter", "Jupiteriano");

for (Map.Entry<String, String> planeta : planetas.entrySet()) {
  System.out.println(planeta.getKey() + " - " + planeta.getValue()); // Mercurio - Mercuriano Venus - Venusiano Tierra - Terricola Marte - Marciano Jupiter - Jupiteriano
}

```

## Calculando con API's de Math

- Son APIS para realizar calculos matematicos.

### Usando min(), max()

- El metodo `min()` retorna el valor mas pequeño.
- El metodo `max()` retorna el valor mas grande.

Ejemplo:

```java

System.out.println(Math.min(1, 2)); // 1

System.out.println(Math.max(1, 2)); // 2

```

### Usando round()

- El metodo `round()` redondea un numero.
- El metodo `round()` recibe un double y retorna un long.
- El metodo `round()` recibe un float y retorna un int.
- El metodo `round()` redondea al numero mas cercano.
- El metodo `round()` redondea al numero par mas cercano si el numero es equidistante.
- El metodo `round()` redondea al numero mas grande si el numero es equidistante y negativo.
- El metodo `round()` redondea al numero mas pequeño si el numero es equidistante y positivo.
  
  Ejemplo:

```java

System.out.println(Math.round(1.5)); // 2

System.out.println(Math.round(1.4)); // 1

System.out.println(Math.round(1.6)); // 2

System.out.println(Math.round(-1.5)); // -1

System.out.println(Math.round(-1.4)); // -1

System.out.println(Math.round(-1.6)); // -2

```

### Usando pow()

- El metodo `pow()` eleva un numero a una potencia.
- El metodo `pow()` recibe un double y retorna un double.
- El metodo `pow()` recibe un float y retorna un float.
- El metodo `pow()` recibe un int y retorna un double.
- El metodo `pow()` recibe un long y retorna un double.

ejemplo:

```java

System.out.println(Math.pow(2, 2)); // 4.0

System.out.println(Math.pow(2.0, 2.0)); // 4.0

System.out.println(Math.pow(2.0, 2)); // 4.0

System.out.println(Math.pow(2, 2.0)); // 4.0

```

### Usando random()

- El metodo `random()` retorna un numero aleatorio entre 0.0 y 1.0.
- El metodo `random()` retorna un double.

Ejemplo:

```java


System.out.println(Math.random()); // 0.0 - 1.0

```

## Resumen

- Strings son inmutables.
- Strings son secuencias de caracteres
  - El operador new es opcional
  - El operador new crea un nuevo objeto
  - Si un operando es un String, el otro operando es convertido a String
  - Usar == compara referencias en el pool
  - Usar equals() compara el contenido
- Strings son almacenados en el String Pool
  - StringBuilder es mutable
  - StringBuilder es usado para crear Strings
  - Usar == compara referencias
  - Usar equals() compara el contenido
- Los arrays son grupos de objetos del mismo tipo
  - Una vez que se ha creado un array, no se puede cambiar su tamaño
  - Se ordenan con Arrays.sort()
- ArrayList es una lista de objetos del mismo tipo
  - Se puede cambiar su tamaño
  - Se ordenan con Collections.sort()

---

## Preguntas de repaso

### 1. ¿Qué genera el siguiente código? (Elija todas las que correspondan)

```java
public class Pez {
  public static void (String [] argumentos) {
    int numPez = 4;
    String tipopez = "atún";
    String otroPescado = numPez + 1;
    System.out.println(otroPescado + " " + tipopez);
    System.out.println(numPez + " " + 1);
 }
}
```

1. [ ] A. 4 1
1. [ ] B. 5
1. [ ] C. 5 atún
1. [ ] D. 5atún
1. [ ] E. 51atún
1. [x] F. El código no se compila.

Respuesta: F

Explicación:

El codigo no se compila por que otroPecado es un String y numPez es un int.

### 2. ¿Cuáles de los siguientes resultados genera este código? (Elija todas las que correspondan)

```java

 var s = "Hola";
 var t = new String(s);
 if ("Hola".equals(s)) System.out.println("uno");
 if (t == s) System.out.println("dos");
 if (t.intern() == s) System.out.println("tres");
 if ("Hola" == s) System.out.println("cuatro");
 if ("Hola".intern() == t) System.out.println("cinco");

```

1. [x] A. uno
1. [ ] B. dos
1. [x] C. tres
1. [x] D. cuatro
1. [ ] E. cinco
1. [ ] F. El código no se compila.
1. [ ] G. Ninguna de las anteriores

Respuesta: A, C, D

Explicación:

- La linea 1 compara el contenido de s con "Hola", por lo que imprime uno.
- La linea dos compara las referencias de t y s, por lo que no imprime nada.
- La linea tres compara las referencias de t y s, usando intern() para obtener la referencia del String en el String Pool, por lo que imprime tres.
- La linea cuatro compara el contenido de s con "Hola", por lo que imprime cuatro.
- La linea cinco compara las referencias de "Hola" y t, usando intern() para obtener la referencia del String en el String Pool, por lo que no imprime nada.

### 3. ¿Qué afirmaciones sobre el siguiente fragmento de código son correctas? (Elija todas las que correspondan)

```java

List<String> gorilas = new ArrayList<>();
for (var k: gorilas)
System.out.println(k);
var monos = new ArrayList<>();
for(var al: monos) System.out.println(al);
List chimpances = new ArrayList<Integer>();
for(var l: chimpances) System.out.println(l);
```

1. [x] A. El tipo de datos de k es String.
1. [ ] B. El tipo de datos de k es Objeto.
1. [x] C. El tipo de datos de al es Objeto.
1. [ ] D. El tipo de datos de al no está definido.
1. [ ] E. El tipo de datos del l es entero.
1. [x] F. El tipo de datos de l es Objeto.
1. [ ] G. Ninguna de las anteriores, ya que el código no se compila

Respuesta: A, C, F

Explicación:

- La variable k es String por que gorlinas esta definido como List<String>.
- La variable al es objeto por que monos no esta definido, de manera predeterminada sera una lista de Object.
- El tipo de datos de l es Object por que chimpances esta definido como List, de manera predeterminada sera una lista de Object.

### 4. ¿Cuál es el resultado del siguiente código?

```java
 StringBuilder sb = new StringBuilder();
 sb.append("aaa").insert(1, "bb").insert(4, "ccc"); 
 System.out.println(sb);
```

1. [ ] A. abbaaccc
1. [x] B. abbaccca
1. [ ] C. bbaaaccc
1. [ ] D. bbaaccca
1. [ ] E. Una línea vacía
1. [ ] F. El código no se compila.

Respuesta: B

Explicación:

- La linea 1 crea un StringBuilder vacio.
- La linea 2 agrega "aaa" al StringBuilder, por lo que sb = "aaa".
- La linea 2 inserta "bb" en la posicion 1, por lo que sb = "abbaa".
- La linea 2 inserta "ccc" en la posicion 4, por lo que sb = "abbaccca".
- La linea 3 imprime "abbaccca".

### 5. ¿Cuál es el resultado del siguiente código?  

```java
int cuenta = 0;
String s1 = "java";
String s2 = "java";
StringBuilder s3 = nuevo StringBuilder("java");
if (s1 == s2) cuenta++;
if (s1.equals(s2)) cuenta++;
if (s1 == s3) cuenta++;
if (s1.equals(s3)) cuenta++;
System.out.println(cuenta);
```

1. [ ] A. 0
1. [ ] B. 1
1. [ ] C. 2
1. [ ] D. 3
1. [ ] E. 4
1. [ ] F. Se lanza una excepción.
1. [x] G. El código no se compila.

Respuesta: G

Explicación:

- La linea 1 crea una variable cuenta con valor 0.
- La linea 2 crea una variable s1 con valor "java".
- La linea 3 crea una variable s2 con valor "java".
- La linea 4 crea una variable s3 con valor "java".
- El codigo no se compila por que s3 es un StringBuilder y s1 es un String.

### 6. ¿Cuál es el resultado del siguiente código?

```java
 public class Leon {
  public void rugido(String rugido1, StringBuilder rugido2) {   
    rugido1.concat("!!!");
    rugido2.append("!!!"); 
  }
  public static void main(String[] args) { 
    String rugido1 = "rugido";
    StringBuilder rugido2 = nuevo StringBuilder("rugido");  new Leon().rugido(rugido1, rugido2); 
    System.out.println(rugido1 + " " + rugido2);
  } 
}
```

1. [ ] A. rugido rugido
1. [x] B. rugido rugido!!!
1. [ ] C. rugido!!! rugido
1. [ ] D. rugido!!! rugido!!!
1. [ ] E. Se lanza una excepción.
1. [ ] F. El código no se compila.

Respuesta: B

Explicación:

- La linea 1 crea una clase Leon.
- La linea 2 crea un metodo rugido con dos parametros, uno de tipo String y otro de tipo StringBuilder.
- La linea 3 concatena "!!!" al String rugido1, pero no lo guarda en ninguna variable.
- La linea 4 agrega "!!!" al StringBuilder rugido2, por lo que rugido2 = "rugido!!!".
- La linea 5 crea un metodo main.
- La linea 6 crea una variable rugido1 con valor "rugido".
- La linea 7 crea una variable rugido2 con valor "rugido".
- La linea 8 llama al metodo rugido, por lo que rugido1 = "rugido" y rugido2 = "rugido!!!".
- La linea 9 imprime "rugido rugido!!!".

### 7. ¿Cuál de los siguientes devuelve el número 5 cuando se ejecuta de forma independiente? (Elija todas las que correspondan)

```java

var cadena = "12345";
var constructor = new StringBuilder("12345");

```

1. [x] A. constructor.charAt(4)
1. [x] B. constructor.replace(2, 4, "6").charAt(3)
1. [ ] C. constructor.replace(2, 5, "6").charAt(2)
1. [ ] D. cadena.charAt(5)
1. [ ] E. cadena.length
1. [x] F. cadena.replace("123", "1").charAt(2)
1. [ ] G. Ninguna de las anteriores

Respuesta: A, B, F

Explicación:

- La linea 1 crea una variable cadena con valor "12345".
- La linea 2 crea una variable constructor con valor "12345".
- La opcion A retorna el caracter en la posicion 4, por lo que retorna 5.
- La opcion B reemplaza los caracteres en la posicion 2 y 3 por "6", por lo que constructor = "1265", luego retorna el caracter en la posicion 3, por lo que retorna 5.
- La opcion F reemplaza "123" por "1", por lo que cadena = "145", luego retorna el caracter en la posicion 2, por lo que retorna 5.
- Las demas opciones no retornan 5.

### 8. ¿Qué genera el siguiente código? (Elija todas las que correspondan)

```java

String numeros = "012345678";
System.out.println(numeros.substring(1, 3));
System.out.println(numeros.substring(7, 7));
System.out.println(numeros.substring(7));

```

1. [x] A. 12
1. [ ] B. 123
1. [ ] C. 7
1. [x] D. 78
1. [x] E. Una línea en blanco
1. [ ] F. El código no se compila.
1. [ ] G. Se lanza una excepción.

Respuesta: A, D, E

Explicación:

- La linea 1 crea una variable numeros con valor "012345678".
- La linea 2 imprime los caracteres desde la posicion 1 hasta la posicion 3, por lo que imprime "12".
- La linea 3 imprime los caracteres desde la posicion 7 hasta la posicion 7, por lo que imprime una linea en blanco.
- La linea 4 imprime los caracteres desde la posicion 7 hasta el final, por lo que imprime "78".

### 9. ¿Cuál es el resultado del siguiente código? (Elija todas las que correspondan)

```java
 
 String s1 = "purr";
 String s2 = ""; 
 
s1.toUpperCase(); 
s1.trim();
s1.substring(1, 3); 
s1 += "dos";

s2 += 2; 
s2 += 'c'; 
s2 += false;

if ( s2 == "2cfalse") System.out.println("==");
 if ( s2.equals("2cfalse")) System.out.println("equals");
 System.out.println(s1.length());

```

1. [ ] A. 2
1. [ ] B. 4
1. [x] C. 7
1. [ ] D. 10
1. [ ] E. ==
1. [x] F. equals
1. [ ] G. Se lanza una excepción.
1. [ ] H. El código no se compila.

Respuesta: C, F

Explicación:

- La linea 1 crea una variable s1 con valor "purr".
- La linea 2 crea una variable s2 con valor "".
- La linea 4 convierte s1 a mayusculas, pero no lo guarda en ninguna variable.
- La linea 5 elimina los espacios en blanco de s1, pero no lo guarda en ninguna variable.
- La linea 6 crea una subcadena de s1 desde la posicion 1 hasta la posicion 3, pero no lo guarda en ninguna variable.
- La linea 7 concatena "dos" a s1, por lo que s1 = "purrdos".
- La linea 9 concatena 2 a s2, por lo que s2 = "2".
- La linea 10 concatena 'c' a s2, por lo que s2 = "2c".
- La linea 11 concatena false a s2, por lo que s2 = "2cfalse".
- La linea 13 compara las referencias de s2 y "2cfalse", como son diferentes, no imprime nada.
- La linea 14 compara el contenido de s2 y "2cfalse", como son iguales, imprime "equals".
- La linea 15 imprime el tamaño de s1, por lo que imprime 7.  

### 10. ¿Cuáles de estas afirmaciones son ciertas? (Elija todas las que correspondan)

```java
var letras = new StringBuilder("abcdefg");
```

1. [x] A. letras.substring(1, 2) devuelve una String de un solo carácter.
1. [ ] B. letras.substring(2, 2) devuelve una String de un solo carácter.
1. [ ] C. letras.substring(6, 5) devuelve una String de un solo carácter.
1. [ ] D. letras.substring(6, 6) devuelve una String de un solo carácter.
1. [ ] E. letras.substring(1, 2) genera una excepción.
1. [ ] F. letras.substring(2, 2) genera una excepción.
1. [x] G. letras.substring(6, 5) genera una excepción.
1. [ ] H. letras.substring(6, 6) genera una excepción.

Respuesta: A, G

Explicación:

- La linea 1 crea una variable letras con valor "abcdefg".
- La opcion A retorna la subcadena desde la posicion 1 hasta la posicion 2, por lo que retorna "b".
- La opcion B retorna la subcadena desde la posicion 2 hasta la posicion 2, por lo que retorna "".
- La opcion C retorna la subcadena desde la posicion 6 hasta la posicion 5, pero la posicion 5 no existe, por lo que lanza una excepcion.
- La opcion D retorna la subcadena desde la posicion 6 hasta la posicion 6, por lo que retorna "".
- La opcion E retorna la subcadena desde la posicion 1 hasta la posicion 2, por lo que retorna "b".
- La opcion F retorna la subcadena desde la posicion 2 hasta la posicion 2, por lo que retorna "".
- La opcion G retorna la subcadena desde la posicion 6 hasta la posicion 5, pero la posicion 5 no existe, por lo que lanza una excepcion.
- La opcion H retorna la subcadena desde la posicion 6 hasta la posicion 6, por lo que retorna "".

### 11. ¿Cuál es el resultado del siguiente código?

```java

StringBuilder numeros = new StringBuilder ("0123456789");
numeros.delete(2, 8);
numeros.append("-").insert(2, "+");
System.out.println(numeros);

```

1. [x] A. 01+89–
1. [ ] B. 012+9–
1. [ ] C. 012+–9
1. [ ] D. 0123456789
1. [ ] E. Se lanza una excepción.
1. [ ] F. El código no se compila.

Respuesta: A

Explicación:

- La linea 1 crea una variable numeros con valor "0123456789".
- La linea 2 elimina los caracteres desde la posicion 2 hasta la posicion 8, por lo que numeros = "0189".
- La linea 3 agrega "-" al final de numeros, por lo que numeros = "0189-".
- La linea 3 inserta "+" en la posicion 2, por lo que numeros = "01+89-".
- La linea 4 imprime "01+89-".

### 12. ¿Cuál es el resultado del siguiente código?

```java
StringBuilder b = "trueno"; 
b.append(4).deleteCharAt(3).delete(3, b.length() - 1);
System.out.println(b);

```

1. [ ] A. tru
1. [ ] B. tru4
1. [ ] C. true4
1. [ ] D. trueno4
1. [ ] E. Se lanza una excepción.
1. [x] F. El código no se compila.

Respuesta: F

Explicación:

- El codigo no compila por que la linea 1 crea un StringBuilder con valor "trueno", pero no se usa el operador new.

### 13. ¿Cuál de las siguientes opciones puede reemplazar la línea 4 para imprimir "avaJ"? (Elija todas las que correspondan)

```java
 var rompecabezas = nuevo StringBuilder("Java");
 // INSERTAR EL CÓDIGO AQUÍ
 System.out.println(rompecabezas);
```

1. [x] A. rompecabezas.reverse();
1. [ ] B. rompecabezas.append("vaJ$").substring(0, 4);
1. [x] C. rompecabezas.append("vaJ$").delete(0, 3).deleteCharAt(rompecabezas.length() - 1);
1. [ ] D. rompecabezas.append("vaJ$").delete(0, 3).deleteCharAt(rompecabezas.length());
1. [ ] E. Ninguna de las anteriores

Respuesta: A, C

Explicación:

- La linea 1 crea una variable rompecabezas con valor "Java".
- La opcion A invierte el valor de rompecabezas, por lo que rompecabezas = "avaJ".
- La opcion B agrega "vaJ$" al final de rompecabezas, por lo que rompecabezas = "Java$". Luego crea una subcadena desde la posicion 0 hasta la posicion 4, por lo que rompecabezas = "Java".
- La opcion C agrega "vaJ$" al final de rompecabezas, por lo que rompecabezas = "JavavaJ$".Luego elimina los caracteres desde la posicion 0 hasta la posicion 3, por lo que rompecabezas = "avaJ$". Luego elimina el caracter en la posicion 6, por lo que rompecabezas = "avaJ".
- La opcion D agrega "vaJ$" al final de rompecabezas, por lo que rompecabezas = "JavavaJ$".Luego elimina los caracteres desde la posicion 0 hasta la posicion 3, por lo que rompecabezas = "avaJ$". Luego elimina el caracter en la posicion 7, pero la posicion maxima es 6, por lo que lanza una excepcion.

### 14. ¿Cuál de estas declaraciones de matrices no es legal? (Elija todas las que correspondan)

1. [ ] A. int[][] puntuaciones = new int[5][];
1. [ ] B. Objeto[][][] cubículos = new Objeto[3][0][5];
2. [x] C. String frijol[] = new frijol[6];
3. [ ] D. java.util.Date[] fechas[] = new java.util.Date[2][];
4. [x] E. int[][] tipos = new int[];
5. [x] F. int[][] java = new int[][];

Respuesta: C, E, F

Explicación:

- La opcion A crea una matriz de 5 filas y columnas indefinidas.
- La opcion B crea una matriz de 3 filas, 0 columnas y 5 profundidad.
- La opcion C crea una matriz de 6 filas y columnas indefinidas, pero el tipo de dato no es String.
- La opcion D crea una matriz de 2 filas y columnas indefinidas.
- La opcion E crea una matriz de 0 filas y columnas indefinidas. El tamaño de la matriz debe ser definido.
- La opcion F crea una matriz de 0 filas y columnas indefinidas. El tamaño de la matriz debe ser definido.

### 15. ¿Cuál de los siguientes puede completar los espacios en blanco para que el código se compile? (Escoge dos.)

```java

 char[] c = new char[2];
 ArrayList l = new ArrayList();
 int longitud  = ______ + ______;

```

1. [x] A. c.length
1. [ ] B. c.length()
1. [ ] C. c.size
1. [ ] D. c.size()
1. [ ] E. l.length
1. [ ] F. l.length()
1. [ ] G. l.size
1. [x] H. l.size()

Respuesta: A, H

Explicación:

- La linea 1 crea una matriz de 2 filas y columnas indefinidas.
- La linea 2 crea un ArrayList vacio.
- La linea 3 crea una variable longitud con valor 2.
- La opcion A retorna el tamaño de la matriz, por lo que longitud = 2.
- La opcion H retorna el tamaño del ArrayList, por lo que longitud = 0.
- La opcion B lanza una excepcion por que length no es un metodo.
- La opcion C lanza una excepcion por que size no es un atributo.
- La opcion D lanza una excepcion por que size no es un metodo.
- La opcion E lanza una excepcion por que length no es un atributo.
- La opcion F lanza una excepcion por que length no es un metodo.
- La opcion G lanza una excepcion por que size no es un atributo.

### 16. ¿Cuáles de las siguientes afirmaciones son ciertas? (Elija todas las que correspondan)

1. [x] A. Una matriz tiene un tamaño fijo.
1. [ ] B. Una ArrayList tiene un tamaño fijo.
1. [ ] C. Una matriz es inmutable.
1. [ ] D. Una ArrayList es inmutable.
1. [ ] E. Llamar a equals() en dos matrices devuelve verdadero.
1. [x] F. Llamar a equals() en dos objetos ArrayList devuelve verdadero.
1. [x] G. Si llama a remove(0) usando un objeto ArrayList vacío, se compilará exitosamente.
1. [ ] H. Si llama a remove(0) usando un objeto ArrayList vacío, se ejecutará correctamente.

Respuesta: A, F, G

Explicación:

- La opcion A es correcta por que una matriz tiene un tamaño fijo.
- La opcion B es incorrecta por que una ArrayList tiene un tamaño variable.
- La opcion C es incorrecta por que una matriz es mutable.
- La opcion D es incorrecta por que una ArrayList es mutable.
- La opcion E es incorrecta por que equals() compara las referencias de las matrices.
- La opcion F es correcta, por que equals() compara el contenido de los ArrayList.
- La opcion G es correcta por que remove(0) no hace nada si el ArrayList esta vacio.
- La opcion H es incorrecta por que si el ArrayList esta vacio, remove(0) lanza una excepcion.

### 17. ¿Cuál es el resultado de las siguientes afirmaciones?

```java

 var lista = new ArrayList<String>(); //6
 lista.add("uno"); //7
 lista.add("dos"); //8
 lista.add(7); //9
 for(var s: lista) System.out.print(s); //10

```

1. [ ] A. unodos
1. [ ] B. unodos7
1. [ ] C. unodos seguido de una excepción
1. [ ] D. Error del compilador en la línea 6
1. [ ] E. Error del compilador en la línea 7
1. [x] F. Error del compilador en la línea 9
1. [ ] G. Error del compilador en la línea 10

Respuesta: F

Explicación:

- La linea 6 crea un ArrayList vacio.
- La linea 7 agrega "uno" al ArrayList.
- La linea 8 agrega "dos" al ArrayList.
- La linea 9 agrega 7 al ArrayList, pero el tipo de dato no es String.
  
### 18. ¿Cuál de los siguientes pares llena los espacios en blanco para obtener el resultado 6?

```java

 var valores = new _________ <Integer>();
 valores.add(4);
 valores.add(4);
 valores._________ ;
 valores.remove(0);
 for (var v: valores) System.out.print(v);

```

1. [ ] A. ArrayList y put(1, 6)
1. [ ] B. ArrayList y replace (1, 6)
1. [x] C. ArrayList y set(1, 6)
1. [ ] D. HashSet y put(1, 6)
1. [ ] E. HashSet y replace(1, 6)
1. [ ] F. HashSet y set(1, 6)
1. [ ] G. El código no se compila con ninguna de estas opciones.

Respuesta: C

Explicación:

- La linea 1 crea un ArrayList vacio.
- La linea 2 agrega 4 al ArrayList.
- La linea 3 agrega 4 al ArrayList.
- La linea 4 reemplaza el valor en la posicion 1 por 6, por lo que valores = [4, 6].
- La linea 5 elimina el valor en la posicion 0, por lo que valores = [6].
- La linea 6 imprime 6.
- La opcion A es incorrecta por que put() no existe en ArrayList.
- La opcion B es incorrecta por que replace() no existe en ArrayList.
- La opcion D es incorrecta por que put() no existe en HashSet.
- La opcion E es incorrecta por que replace() no existe en HashSet.
- La opcion F es incorrecta por que set() no existe en HashSet.
- La opcion G es incorrecta por que el codigo se compila con la opcion C.
-

### 19. ¿Qué resulta de lo siguiente? (Elija todas las que correspondan)

```java

 List<Integer> lista = Arrays.asList(10, 4, -1, 5);
 int[] matriz = {6, -4, 12, 0, -10};
 Collections.sort(lista);

 Integer convertido[] = list.toArray(new Integer[4]);
 System.out.println(convertido[0]);
 System.out.println(Arrays.binarySearch(matriz, 12));

```

1. [x] A. -1
1. [ ] B. 2
1. [ ] C. 4
1. [ ] D. 6
1. [ ] E. 10
1. [x] F. Una de las salidas no está definida.
1. [ ] G. Se lanza una excepción.
1. [ ] H. El código no se compila.

Respuesta: A, F

Explicación:

- La linea 1 crea un ArrayList con los valores 10, 4, -1, 5.
- La linea 2 crea una matriz con los valores 6, -4, 12, 0, -10.
- La linea 3 ordena el ArrayList, por lo que lista = [-1, 4, 5, 10].
- La linea 5 convierte el ArrayList en una matriz, por lo que convertido = [-1, 4, 5, 10].
- La linea 6 imprime el valor en la posicion 0, por lo que imprime -1.
- La linea 7 busca el valor 12 en la matriz, pero la matriz no esta ordenada, por lo que retorna un valor indefinido.

### 20. ¿Cuál de las líneas contiene un error de compilación? (Elija todas las que correspondan)

```java

 double uno = Math.pow(1, 2); //23
 int dos = Math.round(1.0); //24
 float tres = Math.random(); //25
 var dobles = new double[] {uno, dos, tres}; //26

 String [] nombres = {"Tomas", "Ricardo", "Enrique"}; //28
 List<String> lista = nombres.asList(); //29
 var otro = Arrays.asList(nombres); //30
 other.set(0, "Susana"); //31

```

1. [ ] A. Línea 23
1. [x] B. Línea 24
1. [x] C. Línea 25
1. [ ] D. Línea 26
1. [x] E. Línea 29
1. [ ] F. Línea 30
1. [ ] G. Línea 31

Respuesta: B, C, E

Explicación:

- La linea 23 crea una variable uno con valor 1.0.
  - El tipo de dato de uno es double.
- La linea 24 crea una variable dos con valor 1.
  - El tipo de dato de dos es int cuando se le llama con un float
  - El tipo de dato es long cuando se le llama con un double
  - El tipo de dato es incompatible
  - La opcion B es correcta
- La linea 25 crea una variable tres con valor 0.0.
  - El tipo de dato que random() regresa es un double.
  - El tipo de dato de tres es float.
  - EL tipo de dato es incompatible
  - La opcion C es correcta.
- La linea 26 crea una matriz de 3 filas con los valores 1.0, 1, 0.0.
  - El tipo de dato de dobles es double[].
- La linea 28 crea una matriz de 3 filas con los valores "Tomas", "Ricardo", "Enrique".
  - El tipo de dato de nombres es String[].
- La linea 29 tiene un error por que asList() no existe en String[].
- La linea 30 crea un ArrayList con los valores ["Tomas", "Ricardo", "Enrique"].
  - El tipo de dato de otro es List<String>.

### 21. ¿Cuál es el resultado de lo siguiente?

```java

List<String> hexadecimal = Arrays.asList("30", "8", "3A", "FF");
Collections.sort(hex);
int x = Collections.binarySearch(hexadecimal, "8");
int y = Collections.binarySearch(hexadecimal, "3A");
int z = Collections.binarySearch(hexadecimal, "4F");

System.out.println(x + " " + y + " " + z);

```

1. [ ] A. 0 1 –2
1. [ ]  B. 0 1 –3
1. [ ] C. 2 1 –2
1. [x] D. 2 1 –3
1. [ ] E. Ninguna de las anteriores
1. [ ] F. El código no se compila.

Respuesta: D

Explicación:

- La linea 1 crea un ArrayList con los valores "30", "8", "3A", "FF".
- La linea 2 ordena el ArrayList, por lo que hexadecimal = ["30", "3A", "8", "FF"].
- La linea 3 busca el valor "8" en el ArrayList, por lo que retorna 2.
- La linea 4 busca el valor "3A" en el ArrayList, por lo que retorna 1.
- La linea 5 busca el valor "4F" en el ArrayList, pero no existe, por lo que retorna -3.

### 22. ¿Cuáles de las siguientes afirmaciones son verdaderas sobre el siguiente código? (Elija todas las que correspondan)

```java

List<Integer> edades = new ArrayList<>();
 edades.add(Integer.parseInt("5")); 
 edades.add(Integer.valueOf("6")); 
 edades.add(7);
 edades.add(null);
 for (int edad: edades) System.out.print(edad);

```

1. [a] A. El código se compila.
1. [x] B. El código genera una excepción de tiempo de ejecución.
1. [ ] C. Exactamente una de las declaraciones add usa autoboxing.
1. [x] D. Exactamente dos de las declaraciones add usan autoboxing.
1. [ ] E. Exactamente tres de las declaraciones add utilizan autoboxing.

Respuesta: A, B, D

Explicación:

- El codigo se compila por que Integer.parseInt("5") retorna un int.
- La linea 1 crea un ArrayList vacio.
- La linea 2 agrega 5 al ArrayList.
  - Usa autoboxing por que Integer.parseInt("5") retorna un int.
- La linea 3 agrega 6 al ArrayList.
  - No usa autoboxing por que Integer.valueOf("6") retorna un Integer.
- La linea 4 agrega 7 al ArrayList.
  - Usa autoboxing por que 7 es un int.
- La linea 5 agrega null al ArrayList.
  - No usa autoboxing por que null no es un tipo de dato primitivo.
- La linea 6 imprime 5 6 7 null.
  - Lanza una excepcion por que no se puede convertir null a int.

### 23. ¿Cuál es el resultado de lo siguiente?

```java

List<String> uno = new ArrayList<String>();
uno.add("abc");
List<String> dos = new ArrayList<>();
dos.add("abc");
if (uno == dos)
System.out.println("A"); 
else if (uno.equals(dos)) System.out.println("B");
    else System.out.println("C");

```

1. [ ] A. A
1. [x] B. B
1. [ ] C. C
1. [ ] D. Se lanza una excepción.
1. [ ] E. El código no se compila.

Respuesta: B

Explicación:

- La linea 1 crea un ArrayList vacio.
- La linea 2 agrega "abc" al ArrayList.
- La linea 3 crea un ArrayList vacio.
- La linea 4 agrega "abc" al ArrayList.
- La linea 5 compara las referencias de uno y dos, como son diferentes, no imprime nada.
- La linea 6 compara el contenido de uno y dos, como son iguales, imprime "B".
- La linea 7 imprime "B".
- La opcion A es incorrecta por que no imprime nada.
- La opcion B es correcta por que imprime "B".
- La opcion C es incorrecta por que no imprime nada.
- La opcion D es incorrecta por que no lanza una excepcion.
- La opcion E es incorrecta por que el codigo se compila.
  
### 24. ¿Qué afirmaciones son verdaderas sobre el siguiente código? (Elija todas las que correspondan)

```java

public void run(Integer [] enteros, Double [] dobles) {
  List<Integer> listaint = Arrays.asList(enteros);
  List<Double> listadoble = List.of(dobles);
  // más código
}
```

1. [ ] A. Se permite agregar un elemento a `listadoble`.
1. [ ] B. Se permite agregar un elemento a `listaint`.
1. [ ] C. Cambiar el primer elemento en `listadoble` cambia el primer elemento en `dobles`.
1. [x] D. Cambiar el primer elemento en `listaint` cambia el primer elemento en `enteros`.
1. [x] E. listadobles es inmutable.
1. [ ] F. listaint es inmutable.

Respuesta: D, E

Explicación:

- La linea 1 crea un metodo run con dos parametros, uno de tipo Integer[] y otro de tipo Double[].
- La linea 2 crea un ArrayList con los valores de enteros.
- La linea 3 crea un ArrayList con los valores de dobles.
- La opcion A es incorrecta por que listadoble es inmutable.
- La opcion B es incorrecta por que listaint es inmutable.
- La opcion C es incorrecta por que listadoble es inmutable.
- La opcion D es correcta por que la listaint esta respaldada por el arreglo enteros.
- La opcion E es correcta por que listadoble es inmutable.
- La opcion F es correcta por que listaint es inmutable.
-

### 25. ¿Cuáles de las siguientes afirmaciones son verdaderas para el siguiente código? (Elija todas las que correspondan)

```java

String[] s1 = { "Camello", "Pavo real", "Llama"}; 
String[] s2 = { "Camello", "Llama", "Pavo real"};
String[] s3 = { "Camello"}; 
String[] s4 = { "Camello", null};

```

1. [x] A. Arrays.compare(s1, s2) devuelve un número entero positivo.
1. [x] B. Arrays.mismatch(s1, s2) devuelve un número entero positivo.
1. [ ] C. Arrays.compare(s3, s4) devuelve un número entero positivo.
1. [x] D. Arrays.mismatch(s3, s4) devuelve un número entero positivo.
1. [ ] E. Arrays.compare(s4, s4) devuelve un número entero positivo.
1. [ ] F. Arrays.mismatch(s4, s4) devuelve un número entero positivo.

Respuesta: A, B, D

Explicación:

- La linea 1 crea una matriz con los valores "Camello", "Pavo real", "Llama".
- La linea 2 crea una matriz con los valores "Camello", "Llama", "Pavo real".
- La linea 3 crea una matriz con el valor "Camello".
- La linea 4 crea una matriz con los valores "Camello", null.
- La opcion A es correcta por que compara los valores de s1 y s2, como s1[1] es mayor que s2[1], retorna un numero positivo.
- La opcion B es correcta por que compara los valores de s1 y s2, como s1[1] es mayor que s2[1], retorna un numero positivo.
- La opcion C es incorrecta por que compara los valores de s3 y s4, como s3[0] es menor que s4[0], retorna un numero negativo.
- La opcion D es correcta por que compara los valores de s3 y s4, como s3[0] es menor que s4[0], retorna un numero negativo.
- La opcion E es incorrecta por que compara los valores de s4 y s4, como s4[0] es igual que s4[0], retorna 0.
- La opcion F es incorrecta por que compara los valores de s4 y s4, como s4[0] es igual que s4[0], retorna 0.
  